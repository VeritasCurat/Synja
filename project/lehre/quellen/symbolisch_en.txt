lesson: programm_structure
"programm_structure_main":::"The entry point of a Java application is the so-called main method. Every Java application must have a main method with the following construction: public static void main(String a[]){}. Inside the curly brackets you can write the code that you want to execute. For example, there could be a System.out.println("Hello");.  System.out.println(); prints out a String on the console and "Hello" is what you want to be printed out."
"programm_structure_import":::"The code of other Java files can be used in your program. This is achieved by an import declaration. An import declaration imports code (that is on your machine) by specifying a path to the appropriate Java files.  You can then use the code by using a simple name rather than the full name that includes the package. Import declarations must be written at the top of a Java file after the package declaration. They look like this: import identifier[.identifier]*; (the * means that the part in [] can be repeated). An identifier is for now just a name like "java" or "math". Here is an example: import java.util.Random; (java is a package, containing util, which contains the class Random.)". You can add * as wildcard to import every path that can be exchanged for the *. For example import java.util.*; would import everything that is stored in util (including java.util.Random)."
"programm_structure_packages":::"A package is used to bind Java files together to a package that can be imported. They look like imports, with the difference that there are no wildcards and they start with "package". A package is declared at the start of the file (e.g. package application.mylibrary;)."
lesson: basics
"comments":::"A comment is not translated by the compiler and is intended for the readers of the source code, for example, as an explanation of an area of code (what it does, why etc.). \n There are three types of comments: \n- Single-line comments: Start at any point of a line and mark the rest of the line as a comment. They are initiated with a // (e.g. //hello).\n- Multi-line Comments: can start at any point in a line and can span as many lines as you want. They start with a /* and end with a */. \n- Java-Doc: They are created like multi-line comments and are above a class or method to explain them. \nComments can include other comments, but every comment must start and be finished correctly. Thus /*\n//\n*/ is legal, while /*//*/ is not (because the */ is not recognized)."
"literals":::"A literal is the source code representation of a value of a primitive type or the null type (empty value). Thus, literals can be numbers (4 or 4.2), characters ('a'), Strings ("hello"), booleans (true and false) or the empty value null."
"integer_literals":::"Integer literals are integers (e.g.: -143). They can be written in four bases: \n1. binary: 0b followed by a binary number (the digits 0 and 1). e.g.: 0b11 \n2. octal: 0 followed by an octal number (digits from 0-7). e.g.: 01245 \n 3. hexadecimal 0x followed by a hexadecimal number (digits from 0-9 and letters A-F). e.g.: 0xA31F \n4. decimal (digits from 0-9)."
"floating-point_literals":::"Floating-point-literals represent fractional numbers (e.g.: 1.43). There are two types: float and double. Float-literals literals are written with a decimal fraction with an optional exponent indicator, followed by F (e.g. 15.3E4F = 153000.0). Double-literals can contain an optional D, instead of an F (e.g. 2.21E3D = 2210.0). The first part (before the .) or the second part (not both) are optional and if not defined assumed to be a 0 (e.g. .1F = 0.1F, 1.D = 1.0)."
"character_literals":::"Character literals are all ASCII characters and wrapped with ' (e.g.: 'a' or '$'). Character literals can be assigned to the type char (e.g. char a = 'a'). There are special characters that are not visible characters, but have a function (e.g. '\\n' is a newline): \' (Single quotation mark), \" (Double quotation mark), \\(Backslash), \t (Tab), \b (Backspace), \r (Carriage return), \f (Formfeed)."
"string_literals":::"String literals are Strings, thus they consist of a sequence of characters (e.g. String test = "hello"). Strings can be concatenated with + (e.g. ("two"+" words" is equivalent to "two words"))."
"boolean_literals":::"Boolean literals are supposed to reflect the validity of a statement that can be equal to true or false. Thus, there are the boolean literals true and false. Comparisons are based on a boolean value (e.g. 3 < 9 equals true, 3 > 9  equals false).
"null_literal":::"The literal null marks the absence of a value (it is an empty memory reference). It can be assigned to a variable of any type (e.g. int a = null;) to mark it. If a variable is to be read with a null reference, a NullPointerException (an error) is created. null is used to check if a variable is already initialized by using an expression like var == null (var is a variable and == the equal operator in java)."
"keywords":::"A keyword is a reserved string and has language-defined semantics. Keywords are case-sensitive. Keywords include: abstract, continue, for, new, switch, assert, default, if, package, synchronized, boolean, do, goto, private, this, break, double, implements, protected, throw, byte, else, import, public, throws, case, enum, instanceof, return, transient, catch, extends, int, short, try, char, final, interface, static, void, class, finally, long, strictfp, volatile, const, float, native, super and while."
"identifiers":::"An identifier is the name to reference something in the code (a variable, method, class ...). Identifiers in Java are case-sensitive. An identifier can contain: \nAny Unicode character that is a letter (including numeric letters like roman numerals) or digits. \n- The currency sign (such as $). \n- The underscore character (such as _). \nBut an identifier cannot:\n1. Start with a digit or \n2. be equal to a reserved keyword, null, true or false. \n3. There cannot be two identical identifiers for different structures."
"types":::"Data is stored in different forms called types. The data that matches a certain type can represent something in reality or an idea. For example 3 Strings (name, lastname and address) can be an identification for a person, or 3 integers can represent a color in RGB format. What I described are user defined types. But there are also build in types (which can be used as building blocks for user defined types). The built-in types are called primitive types and are associated to the types of literals you just learned about. There are types for integers (whole numbers): char, int, long, short and byte that differ in the range of numbers they can represent. There are types to represent non-whole numbers: float and double. double can display a broader range of numbers. The type char can also represent characters and the type String represent strings. The type boolean represents the values true and false. \n Here are the ranges for the different integer types: \n • For byte, from -128 to 127 \n • For short, from -32768 to 32767 \n For int, from -2147483648 to 2147483647 \n 	 For long, from -9223372036854775808 to 9223372036854775807 \n • For char, from '\u0000' to '\uffff' inclusive, that is, from 0 to 65535."
"variable_definition":::"Variables can be used to store data. Variables have a name, type and a value associated with that type. They are defined by writing the variable's type, the variable name and then a semicolon. For example: int var;."
"variable_definition_initialization":::"A variable can be defined and initialized in the same statement by assigning a value that matches the type (e.g.: int a = 9;)"
"variable_access":::"A variable that was defined before, can be accessed by using it's identifier. For example: Definition of a variable (int a;) and then access it (by printing it out with System.out.println();): System.out.println(a);"
"variable_reassignment":::"A variable can be reassigned by assigning a matching literal, variable, return of a method or an array element of the same type to it."
lesson: arrays
"array_definition":::"Arrays contain a sequence of variables of the same type. For example 3 integer variables. They always have a fixed size. Arrays are defined like this: type name[]; or this: type[] name;. There is absolutely no difference between these two versions. Before they can be used, they must be declared (the number of elements must be set). An element of an array can be used like a "normal" variable of that type."
"array_declaration":::"An array declaration describes how many elements an array has and initializes them with a standard value (0 for numbers, the empty String for Strings, the empty character for chars, true for booleans or null for other types). After the array declaration, you can use the array (read and write). You can first define an array and then declare it like: arraytype arrayname; arrayname = new type[elements]; (e.g. int[] a; a=new int[3];). But you can also do this in one step: type[] name = new type[dimension] (e.g. int y[] = new int[2]; - this creates the array y with 2 elements). Note: the indices start from 0. That means y has two elements: y[0] and y[1]."
"array_definition_initialization":::"Arrays can be defined, declared and initialized with custom values in one step like this: type value[] = {value1, ..., valueN} (e.g. int a[] = {1,2,3};). This initialization can only be done once together with the definition."
"array_access":::"Arrays are accessed like this: name[index] (e.g. y[0]). For example if you define y like this int y = {1,2};, then System.out.println(y[0]); will access the first element of y and thus print out 1."
"array_reassignment":::"A single element of an array can be reassignment like this: type[index] = value; (e.g. name[3] = "hans";)."
"multidim_array_definition":::"A multidimensional array is an array that contains an array, or arrays of arrays or arrays of arrays of arrays ... . For example a two-dimensional arrays consist of an array of arrays. That means that elements in the first dimension have a one-dimensional arrays. In Java, multi-dimensional arrays are defined like this: type name[]...[]; or type[]...[] name; (e.g. int[][] a; for a two dimensional array). \nHere is an example: an array with the size 1920 * 1080 has 1920 elements in the first dimension. Every element of the first dimension has an array of 1080 elements. An array like this could be used to describe an full-hd image - every element of that array would represent a pixel."
"multidim_array_declaration":::"A multidimensional array can be declared like this: type[]...[] name= new type[dimension1]...[dimensionN]; (e.g. int[][] numbers = new int[3][3]; - this creates the array numbers with 3*3 = 9 elements)."
"multidim_array_access":::"Multidimensional arrays are accessed like this: name[index1]...[indexN] (e.g. if a is declared like this int a[][] = new int[2][2];, a[0][1] is 0.)"
"multidim_array_reassignment":::"The syntax for reassignment of multidimensional arrays looks like this: type[index1]...[indexN] = value; (e.g. a[0][0] = 1;)."
lesson: operators
"arithmetic_operators":::"Arithmetic operators can connect int and float literals, + in addition can be used to concatenate string. + is addition of numbers and Strings, - is subtraction, * is multiplication, / is division, % is modulo. Modulo is the rest from a full-number division (e.g. 2 % 4 equals 2, because 2/4 is 0 with a rest of 2 (2 = 4*0 + 2). 5 % 4 is 1, because 5/4 is 1 rest 1 (1 = 1*4 + 1))."
"operators_prefix":::"To increment means in Java to add 1, to decrement to subtract 1 from an integer. To increment a variable of integer types (int, long, short, byte or char) the increment operator ++, and to decrement it the decrement operator -- can be used (e.g. ++a is equal to a+1, --a is equal to a-1). If an increment or decrement operator is written before a variable, the value is incremented/decremented first and then assigned (e.g. ++a or --a) to the variable. If ++ or -- are written before a variable, they are called prefix operators."
"operators_postfix":::"The increment or decrement operator can be written behind a variable (e.g. a++). If they are written after a variable, the variable is first assigned and then incremented. For example, if the int variable a is 3, System.out.println(a++); prints out 3 because a is assigned and then incremented. That means an additional System.out.println(a); would print out 4.  If ++ or -- are written after a variable, they are called postfix operators."
"comparison_operators":::"Comparison operators can be used to compare numbers. Lesser than: <, greater than: >, less than or equal to: <=, greater than or equal to: >=, not equal to: != and equal to: ==  compare integers and return a boolean literal (true or false based on truthfulness of the comparison). == and != can also compare any other type or null as long both operands are of the same type. It is important to understand that in java = is not a comparison, but an assignment! == is the equal operator of Java."
"logic_operators":::"Logic operators can combine the boolean values true or false. Not only are the literals true and false as operands allowed, but also variables of the type boolean, boolean expressions, methods that return true or false or results from other comparison operations.\n• ! is the logical NOT. The NOT operation inverts a boolean value (true will false, false will be true). e.g. !(3 < 9) evaluates to false,\n• && is the logical AND. The AND operation evaluates to true only if BOTH operands are true (1<3 && 3>1 is false, 1<3 && true is true).  e.g. (!true) && true evaluates to false,\n• || is the logical OR. The OR operation evaluates to true if AT LEAST ONE operand is true (e.g. 1<3 || 3>1 is true, 1>3 || 3>5 is false).\n• ^ is the logical XOR. The XOR operation is true if EXACTLY ONE of the operands is true (1<3 ^ 3>1 is true, 1>3 ^ 3>5 is false). e.g. (true ^ false is true).\nThe round brackets are not necessary, but recommended for readability."
"bitwise_operators":::"Every int type can be represented by a binary number (zeros and ones) (e.g. 4 is represented by 100). Bitwise operators are logical operations on the bit level. There are ~ for bitwise NOT, & for bitwise AND, | for bitwise OR and ^ for bitwise XOR. By interpreting a 1 with true and a 0 with false, these operations can be applied on int, short, long, char and byte. For example: 3 | 2 is 3, because on the bit level 0b11 | 0b01 is 0b11. \nAlso, there are the operators <<, >> and >>> that shift bits. a << n will shift the binary representation of a, n times to the left (0 will be added on the right). a >> n will shift a n times to the right and a >>> n will shift n times to the right and preserve the sign of a. For example if a is 4, then a >> 1 is 2 (0b100 -> 0b10); a << 1 is 8 (0b100 -> 0b1000). a and n can only be a of int type."
"assignment_operators":::"= is the simple assignment. Complex assignment operators do an operation and then assign the value of that operation in one step (e.g. a += 3 is the same as a = a+3). +=, -=, *=, /=, %= are assignment by sum, difference, product, quotient, remainder. <<=, >>=, >>>= are assignment by bitwise left shift, signed right shift and unsigned right shift. &= ^= |= are assignment by bitwise AND, XOR, and OR. Every of these assignment operators does the operation first and the assigns the new value."
lesson: statements
"expressions":::"An expression is a construct consisting of variables, operators and method calls. An expression can always be evaluated. For example 3 + A[0] is evaluated to 8, if A[0] has the value 5."
"statements":::"Statements are units of execution. Every statement needs to end with a semicolon! They can be divided into three groups: expression statements, declaration statements and control flow statements (next lesson). Expression statements contain assignment expressions, ++ and -- and method call(in two lesson). Declaration statements contain any declaration of a variable (or array)."
"code_blocks":::"A block is a sequence of statements enwrapped in { and }. A code block can be empty or have 1 or multiple statements in it. A code block can also contain ... a code block / code blocks. Code blocks are designed to summarize statements that are logically related to a unit that runs later and can be used (i.e. they are used in control structures, method definitions, classes and other)."
lesson: controll_structures
"boolean_expression":::"A boolean expression is an expression that can be evaluated to true or false (e.g.: 2>>1 != 7)."
"if":::"The if statement executes a statement or a code block if a boolean expression is true. \nif(boolean Expression){\n//Code Block\n}\nHere is an example: if(x<0){x*=-1}(After this expression, x will always be positive or 0. If x is positive or 0, the statement is not executed. But if x is negative (i.e. x < 0 is true) and the statement inside the curly brackets is executed.)."
"switch":::"A switch statement is a drop distinction, i.e. a sequence of if statements. The switch statement will execute a code block if a variable has a certain value. This reaction based on a value is called case. The syntax is switch(variable) { case value1: {/*statements;*/ break;}; ... default: /*statements;*/ break; }. The default case is triggered if any other case is not. Code for each case should end with the break keyword, but it is possible to omit it causing the execution to proceed to the next label. Switch statements in Java can use byte, short, char, and int as variables."
"while":::"A while loop executes a code block as long as a boolean expression is true.\n Syntax: while(boolean expression){\n//Code Block\n}. or while(expression)//statement. \n e.g.: int i=0; while(i<10){++i;System.out.println(i);} will iterate i from 0 to 10."
"do_while":::"In the do-while loop, the test is done after each iteration. Consequently, the code is always executed at least once. The syntax is: do {/*code block*/} while (boolean expression); \n int i=0; do{++i;System.out.println(i);}while(i<10); will iterate i from 0 to 10."
"for":::"A for loop iterates a variable and executes a code block as long as a condition is met. For loops in Java include an initializer (e.g. int a=0;), a boolean expression (e.g. false or a < 10) and a counter expression(e.g. a++). But the initializer and counter expression can be any statement. The syntax is: for(statement;boolean_expression;statement){/*codeblock*/} \n Here is an example: for(int i = 0; i < 10; i++){System.out.println(i);}. \nThe two statements and the boolean expression can be empty: for(;;); is a valid, infinite for-loop."
"extended_for":::"The extended for loop goes through all elements of an array. The syntax is: for(variable_definition : array_name){/*codeblock*/} \nFor example: String[] names = {"anna", "john", "mary", "bob"}; for(String name: names)System.out.println(name); Output:"anna", "john", "mary", "bob"."
"break":::"The statement break; can be used to leave a loop prematurely. For example: for(int i=0; i<9; i++){if(i*i >= 9)break;} will break the loop at i=3."
"continue":::"continue; can be used to jump to the head of the loop and thus skipping an iteration. For example: for(int i=0; i<9; i++){if(i % 2 == 0)continue; will skip all iterations where i is even.”
lesson: methods
"method_definition":::"A method allows you to execute a code block based on parameters and  returns a variable/array. The parameters should determine what happens in the code block and what the result of the method is. Methods are defined inside a class. The syntax for a valid method definition is:\n access_modifier modifier returntype name(parameterlist){/*functionbody with return statement*/}\n. The parameter list is a list of variablesdefinitions (without the ;) which is separated by ",". For example, this simple method can return the sum of two int variables: public static int square(int a){return a*a;}. square has the modifiers public and static which determine how the method is accessed. square is the name of the method, int is the type that is returned - the type of the result. The parameter int a determines with which types of arguments this method can be accessed (called). (Everything that can be evaluated to an int (int literal, in )) \n There doesn’t need to be any parameters or a return value. (You would just write void as return then). Thus, the shortest method definition is: void a(){}. This method will actually do nothing. \n void a(int a, String b){} does the same thing, but must be called with an int and a String."
"method_modifiers":::"Methods can have different modifiers in their definition that change how they are accessed. abstract - Abstract methods can be present only in abstract classes. Such methods have no body and must be overridden in a subclass unless it is abstract itself. static - Makes the method static and thus accessible with the class, without creation of a class instance. However static methods cannot access non-static members in the same class. A static method would be called like this: classname.methodname(parameterlist);. final declares that the method cannot be overridden in a subclass. Access modifiers are identical to those used with classes: public, protected, private. Don't worry, I will explain to you what classes are in the next lesson and what these access modifiers mean."
"method_access":::"Methods can be accessed in different ways. Static methods are accessed through class name: classname.method(parameter) (e.g. Math.min(2,3);). A static method that was defined in a class can be accessed without a classname (e.g. min(3,4);). Member methods (non-static) are accessed through an object of that class (e.g. x.equals(y);. Methods can use other methods as arguments (if the parameter and argument type match) (e.g. System.out.println(Math.min(2,3));).)."
lesson: classes
"class_definition":::"Classes offer like methods a way to write code more compactly and reuse code. Classes can be defined like this: class name {//class fields und class methods }. Class constructors can be defined like this: public name(parameter){//Konstruktor}. A class definition can contain variable definitions and method definition (which are called their members)."
"class_modifiers":::"Like in methods, there are some modifiers to change the accessability. abstract - Specifies that a class only serves as a base class and cannot be instantiated. static - Used only for member classes, specifies that the member class does not belong to a specific instance of the containing class. final - Classes marked as final cannot be extended from and cannot have any subclasses."
"inheritance":::"A class can inherit methods and variables to child classes. The syntax for this looks like this: class child_class extends parent_class {...}. \n For example: \n class Person{String name;} \n class Teacher extends Person{void change_name(String newname){this.name = newname;}}. The class Teacher inherits the variable name from Person and can use it in change_name. Children can inherit from children and so on. Thus you can build an inheritance hierarchy."
"access_modifiers":::"Access modifiers specify from where you can see a class definition and therefore instantiate it (create an object). public: from everywhere; protected: from an extended class inside another packages; package (default): other classes inside the same package (this modifier cannot not be used as keyword); private: same class or nested class. For example, if a class A contains a private class B, only A can use B."
"object_declaration":::"If a class was defined, you can declare an object of that class. This object has all variables you defined for the class and can use all non static methods defined in the class definition. The syntax is: classname objectname = new classname();."
"class_fields":::"Fields, or class variables, can be declared inside the class body to describe a state (variables) or change the behaviour of objects (methods). For example: class number{ int value = 0;\n}. They can be accessed like this: objectname.member;. If the field is static, it can be accessed by classname: classname.member;. fields can have modifiers: static - that makes the field a static member (it is accessed by the class, not an object). final - allows the field to be initialized only once in a constructor or inside the initialization block or during its declaration, whichever is earlier. Fields can be modified with access modifiers.  An object can reach its member by using the this keyword. Example: this.a;."
"member_access_variables":::". operator allows access to a variable of a class (e.g. player_one.name)."
"member_access_methods":::". operator also allows to access a member method of a class (e.g. player_one.getName())."