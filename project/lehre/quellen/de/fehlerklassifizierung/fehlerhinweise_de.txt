#Gibt einen Hinweis fuer die Loesung eines Fehlers
lesson: programm_structure
"programm_structure_main":::"main_wrong":::"Versuchen Sie, Ihre main-Methode wie folgt zu erstellen: <b> public static void main (String a []) {} </ b>"
"programm_structure_import":::"import_no_keyword":::"Ihre Importanmeldung muss das Schlüsselwort" import "enthalten."
"programm_structure_import":::"import_wrong_semicolon":::"Die Importdeklaration muss mit einem Semikolon enden."
"programm_structure_import":::"import_error_wildcard":::"Wenn die Importdeklaration einen Platzhalter enthält, kann dieser nur am Ende stehen und es kann nur einen geben."
"programm_structure_import":::"import_wrong_structure":::"Sie sollten die Importdeklaration folgendermaßen schreiben: das Schlüsselwort" import ", dann einen Pfad zu den Importdaten und dann ein Semikolon."
"programm_structure_import":::"import_identifier":::"Bitte verwenden Sie einen oder mehrere gültige Bezeichner. Sagen wir zu Beginn, dies sind nur Namen (eine Folge von Buchstaben)."
"programm_structure_packages":::"package_no_keyword":::"Verwenden Sie das Schlüsselwort" package "für eine Paketdeklaration."
"programm_structure_packages":::"package_wrong_semicolon":::"Beenden Sie Ihre Paketdeklaration mit einem Semikolon."
"programm_structure_packages":::"package_indentifier":::"Verwenden Sie Bezeichner in Ihrer Paketdeklaration. Bezeichner müssen mit Buchstaben geschrieben werden. Zum Beispiel:" source ""
"programm_structure_packages":::"package_wrong_structure":::"Eine Paketdeklaration besteht aus einem Schlüsselwort, einem Pfad zu einer Java-Datei und einem Semikolon.
lesson: basics
"identifiers":::"identifiers_digit":::"Wenn Sie einen Bezeichner schreiben, darf dieser nicht mit einer Ziffer beginnen."
"identifiers":::"identifiers_keyword":::"Sie können keine Schlüsselwörter als Bezeichner verwenden (abstrakt, fortfahren, für, neu, wechseln, bestätigen, Standard, wenn, Paket, synchronisiert, boolesch, tun, gehen, privat, dies, brechen, doppelt, implementiert, geschützt, werfen, byte, sonst, importieren, öffentlich, wirft, fall, enum, instanceof, zurück, transient, fangen, erweitert, int, kurz, versuchen, char, final, Schnittstelle, statisch, void, class, finally, long, strictfp, volatile, const, float, native, super und while). "
"identifiers":::"identifiers_null_boolean":::"Schreiben Sie eine Zeichenfolge, die ungleich" true "," false "oder" null "ist."
"identifiers":::"identifiers_nonletter":::"Ein Bezeichner darf kein Zeichen enthalten, das kein Buchstabe ist."
"keywords":::"keyword_non":::"Schlüsselwörter sind: abstrakt, fortsetzen, für, neu, wechseln, bestätigen, Standard, wenn, Paket, synchronisiert, boolesch, tun, gehen, privat, dies, brechen, doppelt, geräte, geschützt, werfen, byte, sonst, importieren, öffentlich, wirft, fall, enum, instanceof, zurück, transient, fangen, erweitert, int, kurz, versuchen, char, final, schnittstelle, statisch, nichtig, klasse, endlich, long, strictfp, volatile, const, float, native, super und while "
"character_literals":::"char_literal_non":::"Ein Zeichenliteral ist jedes Zeichen, das folgendermaßen geschrieben ist: 'a'."
"boolean_literals":::"boolean_literals_non":::"Die booleschen Literale sind wahr und falsch."
"null_literal":::"null_literal_non":::"Der Null-Literal- / Leerwert wird folgendermaßen geschrieben: null."
"literals":::"literal_non":::"Ein Literal ist entweder eine Ganzzahl, ein Gleitkomma, ein Zeichen, ein String, ein Boolescher Wert oder ein Null-Literal."
"string_literals":::"string_literals_non":::"Ein String-Literal ist eine Folge von Zeichen."
"integer_literals":::"integer_literal_non":::"Ein Integer-Literal muss wie eine Zahl aussehen."
"integer_literals":::"integer_literals_binary_not_empty":::"Eine binäre Ganzzahl muss mindestens 0 oder 1 haben."
"integer_literals":::"integer_literals_non_binary":::"Eine binäre Ganzzahl kann nur aus den Ziffern 0 und 1 bestehen. Sie beginnt mit einem 0b."
"integer_literals":::"integer_literals_hex_not_empty":::"Eine hexadezimale Ganzzahl muss mindestens Zeichen im Bereich 0-9 oder A-F enthalten."
"integer_literals":::"integer_literals_non_hex":::"Eine hexadezimale Ganzzahl kann aus den Ziffern (0-9) und den Buchstaben A, B, C, D, E und F bestehen. Sie beginnt mit einem 0x."
"integer_literals":::"integer_literals_non_octal":::"Eine hexadezimale Ganzzahl kann aus den Ziffern 0,1,2,3,4,5,6 und 7 bestehen."
"integer_literals":::"integer_literals_non_decimal":::"Eine dezimale Ganzzahl kann aus den Ziffern (0-9) bestehen."
"integer_literals":::"integer_literals_byte_oor":::"Der Bereich für Byte reicht von -128 bis 127."
"integer_literals":::"integer_literals_short_oor":::"Der Bereich für kurze Zeit reicht von -32768 bis 32767"
"integer_literals":::"integer_literals_int_oor":::"Der Bereich für int reicht von -2147483648 bis 2147483647."
"integer_literals":::"integer_literals_long_oor":::"Der Bereich für long reicht von -9223372036854775808 bis 9223372036854775807."
"integer_literals":::"integer_literals_char_oor":::"Der Bereich für char reicht von '\ u0000' bis '\ uffff' für Unicode-Zeichen, dh von 0 bis 65535."
"float_literals":::"float_literals_no_point":::"Ein float-Literal muss ein '.' zwischen bis zu ganzzahligen Literalen. Beispiel: 0.9 "
"floating-point_literals":::"float_literals_wrong_prefix":::"float-Literal kann nur mit einer Ziffer" 0b "oder" 0x "beginnen."
"floating-point_literals":::"float_literals_wrong_structure":::"Ein float-Literal beginnt mit einem optionalen Integer-Literal, dann kommt ein Punkt und zuletzt ein Integer-Literal. Zum Beispiel: 3.14"
"string_literals":::"string_literal_non":::"Ein String-Literal beginnt mit einem" und mit einem ". Beispiel:" Test "."
"comments":::"comments_non":::"Ein Kommentar muss / ** / oder // enthalten. Zum Beispiel:" / * comment * / "oder" // comment ""
"comments":::"comments_singleline_wrong_structure":::"Eine einzelne Zeile beginnt mit einem // und enthält nur eine Zeile. Beispiel:" // einzeiliger Kommentar \ n // ein weiterer einzeiliger Kommentar \ n " . "
"comments":::"comments_multiline_wrong_structure":::"Ein mehrzeiliger Kommentar muss mit einem" / * "beginnen und mit einem" * / "enden. Beispiel:" / * \ nmulti \ nline \ ncomment \ n * / "."
"types":::"types_non":::"Gültige Typen sind Byte-, Short-, Int-, Long-, Float-, Double-, Boolean-, Char-, String- und benutzerdefinierte Typen."
"variable_definition_initialization":::"variable_definition_initialization_wrong_semicolon":::"Eine Variablendefinition und -initialisierung muss mit einem Semikolon enden."
"variable_definition_initialization":::"variable_definition_initialization_non_type":::"Eine variable_definition und Initialisierung muss einen primitiven Typ oder einen benutzerdefinierten Typ enthalten."
"variable_definition_initialization":::"variable_definition_initialization_non_identifier":::"Ein Variablenname muss ein gültiger Bezeichner sein."
"variable_definition_initialization":::"variable_definition_initialization_name_double":::"Ein Variablenname muss immer eindeutig sein. Das heißt, unterschiedliche Variablen müssen unterschiedliche Namen haben."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_integer":::"Der Typ in der Variablendefinition muss mit dem Typ des zugewiesenen Werts (Ganzzahl) übereinstimmen."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_float":::"Der Typ in der Variablendefinition muss mit dem Typ des zugewiesenen Werts (float) übereinstimmen."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_boolean":::"Der Typ in der variablen_definition muss mit dem Typ des zugewiesenen Werts übereinstimmen (boolean)."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_char":::"Der Typ in der Variablendefinition muss mit dem Typ des zugewiesenen Werts (char) übereinstimmen."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_string":::"Der Typ in der Variablendefinition muss mit dem Typ des zugewiesenen Werts (String) übereinstimmen."
"variable_definition_initialization":::"variable_definition_initialization_typeclass_no_new":::"Die Variablendefinition und -initialisierung muss das Schlüsselwort new enthalten, wenn ein benutzerdefinierter Typ deklariert wird."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_class":::"Der Typ auf der linken Seite muss mit dem Typ auf der rechten Seite übereinstimmen."
"variable_definition_initialization":::"variable_definition_initialization_contructor_parameter_mismatch":::"Die Parameter stimmen nicht mit den im Konstruktor definierten Parametern überein."
"variable_definition_initialization":::"variable_definition_initialization_contructor_parameter_mismatch_len":::"Die Anzahl der Parameter in der Konstruktordefinition stimmt nicht mit der Anzahl der im Konstruktor definierten Parameter überein: $"
"variable_definition":::"variable_definition_initialization_wrong_structure":::"Eine Variablendefinition und -initialisierung ist eine Variablendefinition (ohne Semikolon), gefolgt von einer Zuweisung."
"variable_definition":::"variable_definition_wrong_structure":::"Die richtige Struktur für eine Variablendefinition lautet: variabletype variablename;"
"variable_definition":::"variable_definition_non_identifier":::"Der Variablenname muss ein gültiger Bezeichner sein."
"variable_definition":::"variable_definition_name_double":::"Dieser Variablenname wurde bereits beansprucht. Verwenden Sie einen anderen."
"variable_definition":::"variable_definition_wrong_semicolon":::"Eine variable_definition endet mit einem;."
"variable_definition":::"variable_definition_non_type":::"Eine variable_definition muss einen bekannten Typ haben. Beispiel: int."
"variable_definition":::"variable_definition_contructor_parameter_mismatch":::"Die Parameter stimmen nicht mit den im Konstruktor definierten Parametern überein."
"variable_access":::"variable_access_wrong_structure":::"Ein variabler Zugriff besteht aus dem Variablennamen."
"variable_access":::"variable_access_unknown":::"Eine Variable muss vor dem Zugriff immer definiert werden. Dann kann über ihren Namen auf sie zugegriffen werden."
"variable_reassignment":::"variable_reassignment_wrong_structure":::"Eine variable Neuzuweisung muss folgendermaßen aussehen: variable_name assignation_operator value;"
lesson: operators
"class_and_method_operators":::"memberaccess_wrong_structure":::"Ein Memberzugriff muss folgendermaßen aussehen: class.member."
"class_and_method_operators":::"member_access_non_member":::"Sie können nur auf Mitglieder zugreifen, die in der Klassendefinition aufgeführt sind."
"operator_prefix":::"preincdec_no_operator":::"Der ++ oder - Operator muss verwendet werden. Zum Beispiel ++ var ;, wenn var eine Ganzzahlvariable ist."
"operator_prefix":::"preincdec_wrong_type":::"Für ++ oder - sind nur ganzzahlige Typen zulässig. Zum Beispiel ++ a; wenn a eine int-Variable ist."
"operator_prefix":::"preincdec_wrong_structure":::"Eine Präfixoperation muss folgendermaßen aufgebaut sein: ein Präfixoperator (++ oder -) und dann ein Literal, ein Variablenzugriff, ein Arrayzugriff oder ein Methodenzugriff mit dem zurückgegebenen Typ integer und zuletzt ein Semikolon. "
"operator_postfix":::"postincdec_no_operator":::"Der ++ oder - Operator muss verwendet werden. Zum Beispiel: a ++ ;, wenn a eine Ganzzahlvariable ist."
"operator_postfix":::"postincdec_wrong_type":::"Für ++ oder - sind nur ganzzahlige Typen zulässig. Beispiel: c-- ;, wenn c eine ganzzahlige Variable ist."
"operator_postfix":::"postincdec_wrong_structure":::"Rechter Build für eine Postfix-Operation: Ein Literal-, Variablen-, Array- oder Methodenzugriff mit einem zurückgegebenen Integer-Typ, dann ein Postfix-Operator (++ oder -) und last ein Semikolon. "
"logic_operators":::"logic_operators_no_operator":::"Der Operator ||, && oder! muss verwendet werden. Beispiel: true || false."
"logic_operators":::"logic_operators_wrong_numops":::"Dies hat die falsche Anzahl von Operanden. && und || sollten 2 Operanden haben und! sollte einen Operanden haben."
"logic_operators":::"logic_operators_wrong_type":::"Operanden von logischen Operatoren müssen boolesch sein. Zum Beispiel: true."
"logic_operators":::"logic_operators_wrong_structure":::"Operanden von logischen Operatoren müssen boolesch sein. Beispiel: 3 <10."
"comparison_operators":::"comparison_operators_no_operator":::"Der Operator <, <=,>,> =, == oder! = muss verwendet werden."
"comparison_operators":::"comparison_operators_wrong_numops":::"Es müssen 2 Operanden vorhanden sein."
"Vergleichsoperatoren":::"comparison_operators_wrong_type":::"Operanden von Vergleichsoperatoren müssen ganzzahlig oder vom gleichen Typ sein, wenn sie mit == oder! = verglichen werden."
"comparison_operators":::"comparison_operators_wrong_structure":::"Operanden von Vergleichsoperatoren müssen ganzzahlig oder vom gleichen Typ sein, wenn sie mit == oder! = verglichen werden."
"arithmetic_operators":::"arithmetic_operators_no_operator":::"Der Operator +, -, *, / oder% muss verwendet werden."
"arithmetic_operators":::"arithmetic_operators_wrong_numops":::"Es müssen 2 Operanden vorhanden sein."
"arithmetic_operators":::"arithmetic_operators_wrong_type":::"Verwenden Sie Operanden vom Typ int, float oder string (für +). Beispiel: 3 + 4"
"arithmetic_operators":::"arithmetic_operators_wrong_structure":::"Verwenden Sie Operanden vom Typ int, float oder string (für +). Beispiel:" Hallo "+" Welt! "."
"assignment_operators":::"assignment_operators_no_operator":::"Verwenden Sie einen dieser Operanden: - =, + =, / =,% =, << =, >> =, >>> =, & =, ^ =, oder | =. Zum Beispiel: a + = 3; (wenn a eine Ganzzahl var ist). "
"assignment_operators":::"assignment_operators_badLType":::"Verwenden Sie eine Variable als linken Operator."
"assignment_operators":::"assignment_operators_wrong_numops":::"Es müssen 2 Operanden vorhanden sein."
"assignment_operators":::"assignment_operators_wrong_type":::"Operanden von Zuweisungsoperatoren müssen vom Typ Integer oder Float sein."
"assignment_operators":::"assignment_operators_wrong_structure":::"Operanden von Zuweisungsoperatoren müssen vom Typ Integer oder Float sein."
"bitwise_operators":::"bitwise_operators_wrong_numops":::"Es müssen 2 Operanden vorhanden sein."
"bitwise_operators":::"bitwise_operators_no_operator":::"Verwenden Sie den Operator |, & oder ~. Beispiel: ~ 3."
"bitwise_operators":::"bitwise_operators_wrong_type":::"Verwenden Sie Operanden vom Typ Integer. Zum Beispiel 12."
"bitwise_operators":::"bitwise_operators_wrong_structure":::"Die Struktur einer bitweisen Operation lautet: operand op operand für | und & oder: op operand für ~."
lesson: statements
"expressions":::"expression_non":::"Ein Ausdruck besteht aus Variablen, Arrays, Operatoren und Methodenaufrufen."
"statements":::"statement_non":::"Eine Anweisung ist ein Array oder eine Variablendefinition, -Initialisierung oder -Zugriff oder ein Methodenzugriff. Zum Beispiel das Ausdrucken einer 8 mit System.out.println (8); ist eine Anweisung. Es kann sich auch um eine Variablen- oder Arrayzuweisung handeln. "
"statements":::"statement_wrong_semicolon":::"Beenden Sie eine Anweisung mit einem Semikolon. Beispiel: int a = 9 <b>; </ b>"
"code_blocks":::"codeblock_no_brackets":::"Ein Codeblock muss mit {und} umbrochen werden. Zum Beispiel: {int a; int b}"
"code_blocks":::"codeblock_no_statement":::"Ein Codeblock darf nur Anweisungen enthalten."
lesson: controll_structures
"boolean_expression":::"boolean_expression_non":::"Ein boolescher Ausdruck muss mit true oder false ausgewertet werden. Zum Beispiel true || 3 <5 (true ist ein boolesches Literal und 3 <5 ist gleich true. || is ein boolescher Operator. Deshalb ist true || 3 <5 ein boolescher Ausdruck. "
"if":::"if_no_keyword":::"Verwenden Sie das Schlüsselwort if."
"if":::"if_brackets_not_matching":::"Bei jeder öffnenden runden Klammer muss irgendwann eine schließende runde Klammer verwendet werden."
"if":::"if_no_boolean_expression":::"Jede if-Anweisung muss einen booleschen Ausdruck in runden Klammern enthalten. Zum Beispiel: if (2 * 2 <9);"
"if":::"if_non_statement":::"Nach dem booleschen Ausdruck muss entweder eine gültige Anweisung oder ein Codeblock folgen. Beispiel: System.out.println (" Test ");"
"if":::"if_non_codeblock":::"Nach dem booleschen Ausdruck muss entweder eine gültige Anweisung oder ein Codeblock folgen. Beispiel: {}"
"if":::"if_wrong_structure":::"Die if-Anweisung besteht aus 1. dem Schlüsselwort if, 2. einem booleschen Ausdruck in runder Klammer und 3. einer letzten Anweisung oder einem Codeblock. Zum Beispiel: if ( true) {/ * mach etwas * /} "
"while":::"while_no_keyword":::"Jede while-Schleife muss das Schlüsselwort while enthalten. Zum Beispiel: while (true);"
"while":::"while_brackets_not_matching":::"Auf eine öffnende runde Klammer muss irgendwann eine schließende runde Klammer folgen. Zum Beispiel: while ((true));"
"while":::"while_no_boolean_expression":::"Jede while-Anweisung muss einen booleschen Ausdruck in runden Klammern enthalten."
"while":::"while_non_statement":::"Nach dem booleschen Ausdruck muss entweder eine Anweisung oder ein Codeblock stehen."
"while":::"while_non_codeblock":::"Nach dem booleschen Ausdruck muss entweder eine Anweisung oder ein Codeblock folgen."
"while":::"while_wrong_structure":::"Die while-Anweisung besteht aus dem ersten: dem Schlüsselwort while, dem zweiten: einem booleschen Ausdruck in runder Klammer und dem dritten: einer letzten Anweisung oder einem Codeblock."
"while":::"while_break":::"Die break-Anweisung kann nur einmal verwendet werden. Zum Beispiel: while (true) break;"
"while":::"while_continue":::"Die continue-Anweisung kann nur einmal verwendet werden: while (true) {if (a == 0) continue;}"
"do_while":::"do_while_wrong_semicolon":::"Verwenden Sie ein; nach dem booleschen Ausdruck, um die Schleife abzuschließen. Zum Beispiel: do {} while (true);"
"do_while":::"do_while_no_keyword":::"Jede do while-Schleife muss die Schlüsselwörter do und while enthalten."
"do_while":::"do_while_round_brackets_not_matching":::"Einer schließenden runden Klammer muss irgendwann eine öffnende runde Klammer folgen. Zum Beispiel: do {} while ((((false)));"
"do_while":::"do_while_curly_brackets_not_matching":::"Einer schließenden geschweiften Klammer muss an einem bestimmten Punkt in einer öffnenden geschweiften Klammer gefolgt werden. Zum Beispiel: do {{}} while (false);" "
"do_while":::"do_while_no_boolean_expression":::"Jede do while-Anweisung muss einen booleschen Ausdruck in runden Klammern enthalten."
"do_while":::"do_while_non_codeblock":::"Nach dem Booleschen Ausdruck muss entweder eine Anweisung oder ein Codeblock folgen."
"do_while":::"do_while_wrong_structure":::"Die do while-Anweisung besteht aus dem ersten: dem Schlüsselwort do, dem zweiten: einem Codeblock, dem dritten: dem Schlüsselwort while und dem vierten: einem booleschen Ausdruck in runder Klammer und dem letzten Semikolon. "
"do_while":::"do_while_break":::"Die break-Anweisung kann nur einmal verwendet werden. Zum Beispiel: do {break;} while (true);"
"do_while":::"do_while_continue":::"Die continue-Anweisung kann nur einmal verwendet werden. do {continue;} while (3> 2);"
"switch":::"switch_no_keyword":::"Jede switch-Anweisung muss das Schlüsselwort switch enthalten."
"switch":::"switch_round_brackets_not_matching":::"Auf eine öffnende runde Klammer muss irgendwann eine schließende runde Klammer folgen. Beispiel: switch ((a)) {} (a ist eine Ganzzahlvariable)"
"switch":::"switch_curly_brackets_not_matching":::"Auf eine öffnende geschweifte Klammer muss irgendwann eine schließende geschweifte Klammer folgen. Beispiel: switch (q) {case 0: break;} (b ist eine char-Variable) "
"switch":::"switch_non_variable":::"In den runden Klammern muss eine Variable vom Typ" char "," byte "," short "," int "," byte "," string "stehen. Beispiel: switch (c) {} (c ist a int variable). "
"switch":::"switch_wrong_default":::"Ein Standardfall muss folgendermaßen erstellt werden: default: {/ * Codeblock * /} oder default: / * Anweisung * /"
"switch":::"switch_wrong_case":::"Ein case muss folgendermaßen aufgebaut sein: case value: {/ * code block * /} oder case value: / * statement * /"
"switch":::"switch_varval_mismatch":::"Variablentyp und Wert müssen übereinstimmen. Beispiel: switch (S) {case" tom ": break;} (S ist ein String)"
"switch":::"switch_wrong_structure":::"Die switch-Anweisung besteht aus dem ersten: dem Schlüsselwort switch, dem zweiten: einer passenden Variablen in runden Klammern, dem dritten: einem Codeblock mit Fällen (und optionalem Standardfall)."
"switch":::"switch_break":::"Die break-Anweisung kann nur einmal pro Fall verwendet werden."
"extended_for":::"extended_for_no_keyword":::"Jede extended for-Anweisung muss das Schlüsselwort für enthalten."
"extended_for":::"extended_for_wrong_structure":::"Eine erweiterte for-Anweisung besteht aus den drei Hauptteilen: Erstens dem for-Schlüsselwort, zweitens dem head und drittens einem Codeblock. Der head ist folgendermaßen aufgebaut: variable_definition: array . "
"extended_for":::"extended_for_no_variable_definition":::"In den runden Klammern muss eine Variablendefinition stehen. Beispiel:" int a "zum Durchlaufen eines int-Arrays."
"extended_for":::"extended_for_nonarray":::"In den runden Klammern muss ein Zugriff auf ein vorhandenes Array vorhanden sein."
"extended_for":::"extended_for_varar_mismatch":::"Das Array und die Variablendefinition in der runden Klammer müssen vom gleichen Typ sein. Beispiel:" String s "zum Durchlaufen des String-Arrays S."
"extended_for":::"extended_for_break":::"Die break-Anweisung kann nur einmal verwendet werden."
"extended_for":::"extended_for_continue":::"Die continue-Anweisung kann nur einmal verwendet werden."
"extended_for":::"extended_for_noncode_block":::"Sie müssen einen gültigen Codeblock oder eine gültige Anweisung verwenden."
"extended_for":::"extended_for_nonstatement":::"Sie müssen einen gültigen Codeblock oder eine gültige Anweisung verwenden."
"for":::"for_no_keyword":::"Jede for-Anweisung muss das Schlüsselwort for enthalten."
"for":::"for_wrong_structure":::"Eine for-Anweisung besteht aus den 3 Hauptteilen. Erstens dem for-Schlüsselwort, zweitens dem head, drittens einem Codeblock oder einer Anweisung. Der head besteht aus den 3 Teilen, die sind alle optional: erstens: eine Variablendefinition und -initialisierung, eine Neuzuweisung oder nur eine Anweisung, zweitens: ein boolescher Ausdruck, drittens: eine Neuzuweisung oder eine Anweisung. "
"for":::"for_no_variable_definition":::"Das erste Element in den runden Klammern muss eine Variablendefinition, -initialisierung oder -zuweisung oder nichts enthalten."
"for":::"for_no_boolean_expression":::"Das zweite Element in den runden Klammern muss leer oder ein boolescher Ausdruck sein."
"for":::"for_no_increment":::"Das dritte Element muss leer sein, eine Zuweisungsoperation oder eine Anweisung."
"for":::"for_break":::"Die break-Anweisung kann nur einmal verwendet werden."
"for":::"for_continue":::"Die continue-Anweisung kann nur einmal verwendet werden."
"for":::"for_noncode_block":::"Eine for-Anweisung muss entweder einen gültigen Codeblock oder eine gültige Anweisung haben."
"for":::"for_nonstatement":::"Eine for-Anweisung muss entweder einen gültigen Codeblock oder eine gültige Anweisung haben."
lesson: arrays
"array_definition":::"array_definition_no_brackets":::"Array-Definitionen müssen [] haben. Zum Beispiel: int [] a;"
"array_definition":::"array_definition_wrong_structure":::"Eine Arraydefinition sieht aus wie der Name [] oder der Name [] ;: $"
"array_definition":::"array_definition_non_identifier":::"Jeder Arrayname muss ein gültiger Bezeichner sein."
"array_definition":::"array_definition_non_type":::"Eine Variablendefinition muss einen bekannten Typ haben. Zum Beispiel: boolean"
"array_definition":::"array_definition_name_double":::"Jedes definierte Array muss einen eindeutigen Bezeichner haben."
"array_definition":::"array_definition_wrong_semicolon":::"Eine variable_definition muss mit einem Semikolon enden."
"array_definition_initialization":::"array_definition_initialization_no_brackets":::"Für Array-Definitionen und -Initialisierungen muss eine Werteliste in geschweiften Klammern angegeben werden. Beispiel: int [] example = {1,2,3};"
"array_definition_initialization":::"array_definition_initialization_wrong_semicolon":::"Eine Array-Definition muss ein Semikolon beenden."
"array_definition_initialization":::"array_definition_initialization_name_double":::"Jeder Arrayname muss eindeutig sein."
"array_definition_initialization":::"array_definition_initialization_non_type":::"Falscher Typ. Eine Array-Definition und -Initialisierung muss einen primitiven Typ oder einen benutzerdefinierten Typ enthalten."
"array_definition_initialization":::"array_definition_initialization_typemismatch_integer":::"Der Typ in der Array-Definition muss mit dem Typ der zugewiesenen Werte (Ganzzahl) übereinstimmen."
"array_definition_initialization":::"array_definition_initialization_typemismatch_float":::"Der Typ in der Array-Definition muss mit dem Typ der zugewiesenen Werte übereinstimmen (float)."
"array_definition_initialization":::"array_definition_initialization_typemismatch_boolean":::"Der Typ in der array_definition muss mit dem Typ der zugewiesenen Werte übereinstimmen (boolean)."
"array_definition_initialization":::"array_definition_initialization_typemismatch_char":::"Der Typ in der array_definition muss mit dem Typ der zugewiesenen Werte (char) übereinstimmen."
"array_definition_initialization":::"array_definition_initialization_typemismatch_string":::"Der Typ in der array_definition muss mit dem Typ der zugewiesenen Werte (String) übereinstimmen."
"array_definition_initialization":::"array_definition_initialization_wrong_type":::"Der Typ in der Arraydefinition muss mit dem Typ des zugewiesenen Werts übereinstimmen. Beispiel: int a [] = {1,2} (1 und 2 sind beide vom Typ int ). "
"array_definition_initialization":::"array_definition_initialization_wrong_structure":::"Eine Array-Definition und -Initialisierung muss wie diese Array-Definition ohne; aussehen, dann" new type [numberelements]; "oder {value1, ..., valueN};"
"array_definition_initialization":::"array_definition_initialization_typeclass_no_new":::"Dies enthält nicht das Schlüsselwort new."
"array_definition_initialization":::"array_definition_initialization_typemismatch_class":::"Der Typ auf der linken Seite stimmt nicht mit dem Typ auf der rechten Seite überein."
"array_definition_initialization":::"array_definition_initialization_contructor_parameter_mismatch":::"Dies ist keine gültige Array-Definition und -Initialisierung. Die Parameter stimmen nicht mit den im Konstruktor definierten Parametern überein."
"array_definition_initialization":::"array_definition_initialization_contructor_parameter_mismatch_len":::"Dies ist keine gültige Array-Definition und -Initialisierung. Die Anzahl der Parameter in der Konstruktordefinition stimmt nicht mit der Anzahl der in der Deklaration verwendeten Parameter überein."
"array_declaration":::"array_declaration_no_brackets":::"Array-Deklarationen müssen ein [und ein] haben."
"array_declaration":::"array_declaration_no_new":::"Array-Deklarationen müssen das Schlüsselwort new haben."
"array_declaration":::"array_declaration_wrong_semicolon":::"Eine Array-Deklaration muss mit einem Semikolon enden."
"array_declaration":::"array_declaration_name_double":::"Jeder Arrayname muss ein eindeutiger Bezeichner sein."
"array_declaration":::"array_declaration_non_type":::"Eine Array-Deklaration und -Initialisierung muss einen primitiven Typ oder einen benutzerdefinierten Typ enthalten. Zum Beispiel int: int [] a = new int [];"
"array_declaration":::"array_declaration_wrong_type":::"Der Typ in der Array-Deklaration muss mit dem Typ des zugewiesenen Werts übereinstimmen."
"array_declaration":::"array_declaration_wrong_structure":::"Eine Array-Deklaration muss folgendermaßen aussehen: type [] name = new type [elements];"
"array_declaration":::"multidim_array_declaration_wrong_structure":::"Eine Array-Deklaration muss folgendermaßen aussehen: type [] ... [] name = new type [elements] ... [elements] ;: $"
"array_declaration":::"multidim_array_declaration_bracketnumber_not_matching":::"Eine Array-Deklaration muss folgendermaßen aussehen: type [] ... [] name = new type [elements] ... [elements] ;. Die Nummer von [] on Die linke Seite des = muss mit der Zahl [] auf der rechten Seite übereinstimmen (die Zahl [] gibt die Anzahl der Dimensionen an). "
"array_reassignment":::"array_reassignment_unknown_array":::"Ein Array muss definiert und deklariert / initialisiert werden, bevor es neu zugewiesen werden kann."
"array_reassignment":::"array_reassignment_wrong_structure":::"Die Struktur für eine Neuzuweisung lautet: arrayname [index] = value;"
"array_reassignment":::"array_reassignment_non_type":::"Eine Variablendefinition und -initialisierung enthält keinen primitiven oder benutzerdefinierten Typ."
"array_reassignment":::"array_reassignment_non_identifier":::"Der Arrayname muss ein gültiger Bezeichner sein."
"array_reassignment":::"array_reassignment_wrong_semicolon":::"Eine Array-Neuzuweisung muss mit einem Semikolon enden."
"array_reassignment":::"array_reassignment_name_double":::"Jeder Arrayname muss eindeutig sein."
"array_reassignment":::"array_reassignment_wrong_type":::"Der Typ in der Array-Definition stimmt nicht mit dem Typ des zugewiesenen Werts überein. Wenn beispielsweise a ein int-Array ist: a [0] = 9; ist richtig, weil 9 ist vom Typ int.
"array_reassignment":::"array_reassignment_typemismatch_integer":::"Der Typ in der Array-Definition muss mit dem Typ des zugewiesenen Werts (Ganzzahl) übereinstimmen. Wenn beispielsweise a ein int-Array ist, ist a [0] = 3; richtig , weil 3 vom Typ int ist. "
"array_reassignment":::"array_reassignment_typemismatch_float":::"Der Typ in der Array-Definition muss mit dem Typ des zugewiesenen Werts (float) übereinstimmen. Wenn beispielsweise a ein doppeltes Array ist: a [0] = 3,0; ist richtig , weil 3.0 * 2.1 gleich 6.3 ist und das ein Doppelwörtchen ist. "
"array_reassignment":::"array_reassignment_typemismatch_boolean":::"Der Typ in der Array-Definition muss mit dem Typ des zugewiesenen Werts (boolean) übereinstimmen. Wenn a beispielsweise ein boolesches Array ist: a [0] = 3 <2; ist richtig, weil 3 <2 vom Booleschen Typ ist. "
"array_reassignment":::"array_reassignment_typemismatch_char":::"Der Typ in der Array-Definition muss mit dem Typ des zugewiesenen Werts (char) übereinstimmen. Wenn beispielsweise a ein int-Array ist: a [0] = 'a'; ist richtig, weil 'a' vom Typ char ist. "
"array_reassignment":::"array_reassignment_typemismatch_string":::"Der Typ in der Array-Definition muss mit dem Typ des zugewiesenen Werts (String) übereinstimmen. Wenn beispielsweise a ein String-Array ist: a [0] =" element "; ist richtig, weil "Element" vom Typ String ist. "
"array_reassignment":::"array_reassignment_typeclass_no_new":::"Die Array-Definition und -Initialisierung muss das Schlüsselwort new enthalten, wenn ein benutzerdefinierter Typ deklariert ist."
"array_reassignment":::"array_reassignment_typemismatch_class":::"Der Typ auf der linken Seite muss mit dem Typ auf der rechten Seite übereinstimmen."
"array_reassignment":::"array_reassignment_contructor_parameter_mismatch":::"Die Parameter stimmen nicht mit den im Konstruktor definierten Parametern überein."
"array_reassignment":::"array_reassignment_contructor_parameter_mismatch_len":::"Die Anzahl der Parameter in der Konstruktordefinition stimmt nicht mit der Anzahl der in der Deklaration verwendeten Parameter überein."
"array_reassignment":::"array_reassignment_wrong_dim":::"Der Index in der Array-Neuzuweisung muss mit dem Bereich in der Array-Deklaration übereinstimmen."
"array_access":::"array_access_wrong_structure":::"Ein Array-Zugriff besteht aus zwei Teilen: dem Array-Namen und einem gültigen Index, der von [] eingeschlossen ist. Beispiel: ar [2]."
"array_access":::"array_access_unknown_array":::"Jedes Array, auf das Sie zugreifen möchten, muss zuerst definiert und initialisiert / deklariert werden."
"array_access":::"multidim_array_access_unknown_array":::"Jedes Array, auf das Sie zugreifen möchten, muss zuerst definiert und initialisiert / deklariert werden."
"array_access":::"array_access_no_declaration":::"Jedes Array, auf das Sie zugreifen möchten, muss zuerst definiert und initialisiert / deklariert werden."
"array_access":::"array_access_outofrange":::"Ungültiger Index. Der Index ist kleiner als 0 oder größer als das Array."
"multidim_array_definition":::"multidim_array_definition_no_brackets":::"Eine multidimensionale Array-Definition muss [] enthalten."
"multidim_array_definition":::"multidim_array_definition_wrong_semicolon":::"Eine multidimensionale Array-Definition muss mit einem Semikolon enden."
"multidim_array_definition":::"multidim_array_definition_name_double":::"Jedes Array muss einen eindeutigen Namen haben."
"multidim_array_definition":::"multidim_array_definition_non_identifier":::"Der Arrayname muss ein gültiger Bezeichner sein."
"multidim_array_definition":::"multidim_array_definition_non_type":::"Diese Array-Definition muss einen primitiven Typ oder einen benutzerdefinierten Typ haben."
"multidim_array_definition":::"multidim_array_definition_wrong_structure":::"Eine Arraydefinition sieht wie folgt aus:" type [] ... [] name; "oder" type name [] ... []; "
"multidim_array_declaration":::"multidim_array_declaration_bracketnumber_not_matching":::"Die Anzahl der eckigen Klammern auf der linken Seite muss mit der Anzahl der eckigen Klammern auf der linken Seite übereinstimmen: $"
"multidim_array_declaration":::"multidim_array_declaration_wrong_structure":::"Die Struktur der Array-Deklaration ist falsch. Sie muss folgendermaßen aussehen: type [] ... [] name = new type [dimension1] ... [dimensionN]; : $ "
"multidim_array_access":::"multidim_array_access_unknown_array":::"Jedes Array, auf das zugegriffen wird, muss zuerst definiert und deklariert werden."
"multidim_array_access":::"multidim_array_access_no_declaration":::"Jedes Array, auf das zugegriffen wird, muss zuerst definiert und deklariert werden."
"multidim_array_access":::"multidim_array_access_outof_dim":::"Auf ein Array kann nur mit den richtigen Indezes zugegriffen werden. Zum Beispiel: Auf das Array int a [] [] = new int [2] [2] kann nur mit zugegriffen werden die folgenden Indices: a [0] [0], a [0] [1], a [1] [0] oder a [1] [1]. "
"multidim_array_access":::"multidim_array_access_wrong_structure":::"Ein Array-Zugriff sieht wie folgt aus: Arrayname [Dimension1] ... [DimensionN]. Zum Beispiel a [0] [0] für das zweidimensionale Array a."
"multidim_array_access":::"multidim_array_access_oof":::"Jeder Index in einer Array-Neuzuweisung muss über 0 und unter dem in der Array-Deklaration definierten Bereich liegen."
"multidim_array_reassignment":::"multidim_array_reassignment_unknown_array":::"Jedes Array, auf das Sie zugreifen möchten, muss zuerst definiert und initialisiert / deklariert werden."
"multidim_array_reassignment":::"multidim_array_reassignment_no_declaration":::"Das Array wurde definiert, aber nicht deklariert / initialisiert und kann daher nicht verwendet werden: $"
"multidim_array_reassignment":::"multidim_array_reassignment_outof_dim":::"Eine Array-Neuzuweisung muss einen gültigen Index (<0 oder> definierter Index) enthalten."
"multidim_array_reassignment":::"multidim_array_reassignment_wrong_structure":::"Eine Array-Neuzuweisung besteht aus zwei Teilen: Array-Zugriff und dann eine Zuweisung. Zum Beispiel a [0] [1] = 2.1;"
"multidim_array_reassignment":::"multidim_array_reassignment_oof":::"Jeder Index in einer Array-Neuzuweisung muss über 0 und unter dem in der Array-Deklaration definierten Bereich liegen."
lesson: methods
"method_definition":::"method_definition_no_identifier":::"Methodennamen müssen gültige Bezeichner sein."
"method_definition":::"method_definition_wrong_return":::"Der Rückgabetyp muss nicht mit dem im Methodenkopf definierten Rückgabetyp übereinstimmen."
"method_definition":::"method_definition_wrong_type":::"Der Rückgabetyp einer Methode kann ein primitiver Typ, ein benutzerdefinierter Typ oder void sein."
"method_definition":::"method_definition_wrong_modifier":::"Der Methodenmodifier muss statisch oder ein Zugriffsmodifier (öffentlich, privat oder geschützt) sein."
"method_definition":::"method_definition_wrong_variable_definition":::"Alle Variablendefinitionen in runden Klammern müssen gültig sein."
"method_definition":::"method_definition_wrong_structure":::"Eine Methodendefinition besteht aus zwei Hauptteilen: dem Kopf und einem Codeblock. Der Kopf besteht aus optionalen Methodenmodifikatoren, einem Rückkehrtyp, einem Methodennamen und einer Parameterdefinition. Zum Beispiel: Ungültigkeitstest () {} "
"method_modifiers":::"method_defintion_no_mod":::"Verwenden Sie einen dieser Modifikatoren: public, private, protected oder static."
"method_access":::"method_access_wrong_structure":::"Ein Methodenzugriff besteht aus einem Methodennamen und anschließend einer Parameterliste und einem Semikolon. Beispiel: void ();"
"method_access":::"method_access_unknown_method":::"Unbekannter Methodenname. Die Methode muss definiert werden, bevor sie aufgerufen werden kann."
"method_access":::"method_access_parameter_mismatch":::"Alle Parameter im Methodenzugriff müssen mit den Parameterdefinitionen in der Methodendefinition übereinstimmen."
lesson: classes
"class_definition":::"class_definition_no_keyword":::"Eine Klassendefinition muss das Schlüsselwort class enthalten."
"class_definition":::"constructor_definition_wrong_name":::"Der Name des Konstruktors muss mit dem Namen seiner Klasse identisch sein."
"class_definition":::"constructor_definition_wrong_modifier":::"Falscher Modifier: Nur public, protected und private sind erlaubt."
"class_definition":::"constructor_wrong_structure":::"Falsche Struktur für Konstruktor! Die Struktur eines Konstruktors lautet: modifier classname (parameterlist) {/ * code block * /}."
"class_definition":::"constructor_wrong_body":::"Der Rumpf des Konstruktors muss ein gültiger Methodenrumpf sein. Zum Beispiel: {}"
"class_definition":::"class_definition_no_mod":::"Kein Modifikator! Bitte verwenden Sie den Modifikator static, abstract oder final."
"class_definition":::"class_definition_name_double":::"Jeder Klassenname kann nur einmal verwendet werden."
"class_definition":::"class_definition_no_curly_brackets":::"Eine Klassendefinition muss einen von geschweiften Klammern eingerahmten Klassenkörper enthalten. Beispiel: class Test {}"
"class_definition":::"class_definition_invalid_identifier":::"Der Klassenname muss ein gültiger Bezeichner sein."
"class_definition":::"class_definition_invalid_accessmodifier":::"Die Zugriffsmodifier der Klasse müssen gültig sein (public, private, protected)."
"class_definition":::"class_illegal_classblock":::"Ein Klassentext kann nur Variablen- und Methodendefinitionen enthalten."
"class_definition":::"class_definition_wrong_structure":::"Eine Klassendefinition hat die Syntax: optional_access_modifier optional_modifier Klassenname {/ * optional: classmembers * /}"
"access_modifiers":::"class_definition_no_access_mod":::"Nur öffentliche, private oder geschützte sind erlaubt."
"class_modifiers":::"class_definition_no_mod":::"Es wurde kein oder ein falscher Modifikator verwendet: $. static, abstract und final sind erlaubt."
"inheritance":::"inheritance_non_parent":::"Jede untergeordnete Klasse muss eine gültige übergeordnete Klasse haben."
"inheritance":::"inheritance_wrong_structure":::"Die richtige Struktur für eine Vererbung sieht folgendermaßen aus: class child_class extended parent_class {/ * class_body * /}."
"member_access_variables":::"member_access_variables_unknown_object":::"Jedes Objekt muss definiert und deklariert werden, bevor darauf zugegriffen werden kann."
"member_access_variables":::"member_access_variables_unknown_member":::"Die Membervariable muss in der Klassendefinition definiert werden."
"member_access_variables":::"member_access_variables_wrong_structure":::"Rechtes Format für den Zugriff auf Mitglieder: object.member;"
"member_access_methods":::"member_access_methods_unknown_object":::"Jedes Objekt muss definiert und deklariert werden, bevor auf es zugegriffen werden kann."
"member_access_methods":::"member_access_methods_unknown_member":::"Jede Member-Methode muss in der Klassendefinition definiert werden, bevor sie verwendet werden kann."
"member_access_methods":::"member_access_methods_wrong_structure":::"Richtiges Format: object.membermethod (parameter_list);"