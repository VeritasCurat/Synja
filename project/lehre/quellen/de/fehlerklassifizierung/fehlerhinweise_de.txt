#Gibt einen Hinweis fuer die Loesung eines Fehlers
lesson: programm_structure
"programm_structure_main":::"main_wrong":::"Bitte schreibe die main-Methode wie folgt: <b> public static void main (String a []) {} </ b>"
"programm_structure_import":::"import_no_keyword":::"Deine Importdeklaration muss das Schlüsselwort "import" enthalten."
"programm_structure_import":::"import_wrong_semicolon":::"Die Importdeklaration muss mit einem Semikolon enden."
"programm_structure_import":::"import_error_wildcard":::"Wenn die Importdeklaration einen Platzhalter enthält, kann dieser nur am Ende stehen und es kann nur einen geben."
"programm_structure_import":::"import_wrong_structure":::"Du solltest die Importdeklaration folgendermaßen schreiben: das Schlüsselwort "import", dann einen Pfad zu den Importdaten und dann ein Semikolon. Z.B.: import java;"
"programm_structure_import":::"import_identifier":::"Bitte verwende einen oder mehrere gültige Bezeichner. Sagen wir zu Beginn, dies sind nur Namen (eine Folge von Buchstaben)."
"programm_structure_packages":::"package_no_keyword":::"Verwende das Schlüsselwort "package" für eine Paketdeklaration."
"programm_structure_packages":::"package_wrong_semicolon":::"Beende eine Paketdeklaration immer mit einem Semikolon."
"programm_structure_packages":::"package_indentifier":::"Verwende Bezeichner in deiner Paketdeklaration. Bezeichner müssen mit Buchstaben geschrieben werden. Zum Beispiel: 'source'"
"programm_structure_packages":::"package_wrong_structure":::"Eine Paketdeklaration besteht aus einem Schlüsselwort, einem Pfad zu einer Java-Datei und einem Semikolon.
lesson: basics
"identifiers":::"identifiers_digit":::"Wenn du einen Bezeichner schreibst, darf dieser nicht mit einer Ziffer beginnen."
"identifiers":::"identifiers_keyword":::"Du kannst keine Schlüsselwörter als Bezeichner verwenden (abstract, continue, for, new, switch, assert, default, if, package, synchronized, boolean, do, goto, private, this, break, double, implements, protected, throw, byte, else, import, public, throws, case, enum, instanceof, return, transient, catch, extends, int, short, try, char, final, interface, static, void, class, finally, long, strictfp, volatile, const, float, native, super und while)."
"identifiers":::"identifiers_null_boolean":::"Schreibe einen String, der ungleich "true", "false" oder "null" ist."
"identifiers":::"identifiers_nonletter":::"Ein Bezeichner darf kein Zeichen enthalten, das kein Buchstabe ist."
"keywords":::"keyword_non":::"Schlüsselwörter sind: abstract, continue, for, new, switch, assert, default, if, package, synchronized, boolean, do, goto, private, this, break, double, implements, protected, throw, byte, else, import, public, throws, case, enum, instanceof, return, transient, catch, extends, int, short, try, char, final, interface, static, void, class, finally, long, strictfp, volatile, const, float, native, super und while."
"character_literals":::"char_literal_non":::"Ein Zeichenliteral ist jedes Zeichen, das folgendermaßen geschrieben ist: 'a'."
"boolean_literals":::"boolean_literals_non":::"Die beiden booleschen Literale lauten: "true" und "false"."
"null_literal":::"null_literal_non":::"Der Null-Literal- / Nullwert wird folgendermaßen geschrieben: null."
"literals":::"literal_non":::"Ein Literal ist entweder eine Ganzzahl, eine Gleitkommazahl, ein Zeichen, ein String, ein boolesches Literal oder ein Null-Literal."
"string_literals":::"string_literals_non":::"Ein String-Literal ist eine Folge von Zeichen."
"integer_literals":::"integer_literal_non":::"Ein Integer-Literal muss wie eine Zahl aussehen."
"integer_literals":::"integer_literals_binary_not_empty":::"Eine binäre Ganzzahl muss mindestens aus einer 0 oder 1 bestehen."
"integer_literals":::"integer_literals_non_binary":::"Eine binäre Ganzzahl kann nur aus den Ziffern 0 und 1 bestehen. Sie beginnt mit einem 0b."
"integer_literals":::"integer_literals_hex_not_empty":::"Eine hexadezimale Ganzzahl muss mindestens ein Zeichen im Bereich 0-9 oder A-F enthalten."
"integer_literals":::"integer_literals_non_hex":::"Eine hexadezimale Ganzzahl kann aus den Ziffern (0-9) und den Buchstaben A, B, C, D, E und F bestehen. Sie beginnt mit einem 0x."
"integer_literals":::"integer_literals_non_octal":::"Eine hexadezimale Ganzzahl kann aus den Ziffern 0,1,2,3,4,5,6 und 7 bestehen."
"integer_literals":::"integer_literals_non_decimal":::"Eine dezimale Ganzzahl kann aus den Ziffern 0-9 bestehen."
"integer_literals":::"integer_literals_byte_oor":::"Der Bereich von byte reicht von -128 bis 127."
"integer_literals":::"integer_literals_short_oor":::"Der Bereich von short reicht von -32768 bis 32767"
"integer_literals":::"integer_literals_int_oor":::"Der Bereich von int reicht von -2147483648 bis 2147483647."
"integer_literals":::"integer_literals_long_oor":::"Der Bereich von long reicht von -9223372036854775808 bis 9223372036854775807."
"integer_literals":::"integer_literals_char_oor":::"Der Bereich von char reicht von '\ u0000' bis '\ uffff' für Unicode-Zeichen, d.h. von 0 bis 65535."
"float_literals":::"float_literals_no_point":::"Ein float-Literal muss ein '.' zwischen bis zu ganzzahligen Literalen besitzen. Beispiel: 0.9F"
"floating-point_literals":::"float_literals_wrong_prefix":::"Ein float-Literal kann nur mit einem "0b" oder "0x" beginnen."
"floating-point_literals":::"float_literals_wrong_structure":::"Ein float-Literal beginnt mit einem optionalen Integer-Literal, dann folgt ein Punkt und zuletzt ein weiteres Integer-Literal. Zum Beispiel: 3.14F"
"string_literals":::"string_literal_non":::"Ein String-Literal beginnt mit einem " und endet mit einem ". Beispiel:" Test "."
"comments":::"comments_non":::"Ein Kommentar muss /**/ oder // enthalten. Zum Beispiel: /*mehrzeiliger*/ oder  //einzeiliger"
"comments":::"comments_singleline_wrong_structure":::"Ein einzeiliger beginnt mit einem // und enthält nur eine Zeile. Beispiel: "//einzeiliger Kommentar \n //ein weiterer einzeiliger Kommentar."
"comments":::"comments_multiline_wrong_structure":::"Ein mehrzeiliger Kommentar muss mit einem /* beginnen und mit einem  */ enden. Beispiel:  /* \n mehr \n zeiliger \n Kommentar \n */"."
"types":::"types_non":::"Java verfügt über folgende Typen: byte, short, long, int, float, double, char, String und benutzerdefinierte Typen."
"variable_definition_initialization":::"variable_definition_initialization_wrong_semicolon":::"Eine Variablendefinition und -initialisierung muss mit einem Semikolon enden."
"variable_definition_initialization":::"variable_definition_initialization_non_type":::"Eine Variablendefinition und -initialisierung muss einen primitiven Typ oder einen benutzerdefinierten Typ enthalten."
"variable_definition_initialization":::"variable_definition_initialization_non_identifier":::"Ein Variablenname muss ein gültiger Bezeichner sein."
"variable_definition_initialization":::"variable_definition_initialization_name_double":::"Ein Variablenname muss immer eindeutig sein. Das heißt verschiedene Variablen müssen unterschiedliche Namen haben."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_integer":::"Der Typ in der Variablendefinition muss mit dem Typ des zugewiesenen Werts (Ganzzahl) übereinstimmen."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_float":::"Der Typ in der Variablendefinition muss mit dem Typ des zugewiesenen Werts (float) übereinstimmen."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_boolean":::"Der Typ in der Variablendefinition muss mit dem Typ des zugewiesenen Werts übereinstimmen (boolean)."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_char":::"Der Typ in der Variablendefinition muss mit dem Typ des zugewiesenen Werts (char) übereinstimmen."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_string":::"Der Typ in der Variablendefinition muss mit dem Typ des zugewiesenen Werts (String) übereinstimmen."
"variable_definition_initialization":::"variable_definition_initialization_typeclass_no_new":::"Die Variablendefinition und -initialisierung muss das Schlüsselwort new enthalten, wenn ein benutzerdefinierter Typ deklariert wird."
"variable_definition_initialization":::"variable_definition_initialization_typemismatch_class":::"Der Typ auf der linken Seite muss mit dem Typ auf der rechten Seite übereinstimmen."
"variable_definition_initialization":::"variable_definition_initialization_contructor_parameter_mismatch":::"Die Parameter stimmen nicht mit den im Konstruktor definierten Parametern überein."
"variable_definition_initialization":::"variable_definition_initialization_contructor_parameter_mismatch_len":::"Die Anzahl der Parameter in der Konstruktordefinition stimmt nicht mit der Anzahl der im Konstruktor definierten Parametern überein."
"variable_definition":::"variable_definition_initialization_wrong_structure":::"Eine Variablendefinition und -initialisierung ist eine Variablendefinition (ohne Semikolon), gefolgt von einer Zuweisung."
"variable_definition":::"variable_definition_wrong_structure":::"Die richtige Struktur für eine Variablendefinition lautet: variabletype variablename;"
"variable_definition":::"variable_definition_non_identifier":::"Der Variablenname muss ein gültiger Bezeichner sein."
"variable_definition":::"variable_definition_name_double":::"Dieser Variablenname wurde bereits genutzt."
"variable_definition":::"variable_definition_non_type":::"Eine Variablendefinition muss einen bekannten Typ haben. Zum Beispiel: int."
"variable_definition":::"variable_definition_contructor_parameter_mismatch":::"Die Parameter stimmen nicht mit den im Konstruktor definierten Parametern überein."
"variable_access":::"variable_access_wrong_structure":::"Ein variabler Zugriff besteht aus dem Variablennamen."
"variable_access":::"variable_access_unknown":::"Eine Variable muss vor dem Zugriff immer definiert werden. Dann kann über ihren Namen auf sie zugegriffen werden."
"variable_reassignment":::"variable_reassignment_wrong_structure":::"Eine Neuzuweisung einer variable muss folgendermaßen aussehen: variable_name assignation_operator value;"
lesson: operators
"class_and_method_operators":::"memberaccess_wrong_structure":::"Ein Memberzugriff muss folgendermaßen aussehen: class.member."
"class_and_method_operators":::"member_access_non_member":::"Du kannst nur auf Mitglieder zugreifen, die in der Klassendefinition aufgeführt sind."
"operator_prefix":::"preincdec_no_operator":::"Der ++ oder -- Operator muss verwendet werden. Zum Beispiel ++var;, wenn var eine Integervariable ist."
"operator_prefix":::"preincdec_wrong_type":::"Für ++ oder -- sind nur Integer Typen zulässig. Zum Beispiel ++a; wenn a eine int-Variable ist."
"operator_prefix":::"preincdec_wrong_structure":::"Eine Präfixoperation muss folgendermaßen aufgebaut sein: ein Präfixoperator (++ oder --) und dann ein Literal, ein Variablenzugriff, ein Arrayzugriff oder ein Methodenzugriff mit dem zurückgegebenen Typ integer und zuletzt ein Semikolon. "
"operator_postfix":::"postincdec_no_operator":::"Der ++ oder -- Operator muss verwendet werden. Zum Beispiel: a++;, wenn a eine Integervariable ist."
"operator_postfix":::"postincdec_wrong_type":::"Für ++ oder -- sind nur Integertypen zulässig. Beispiel: c--;, wenn c eine Integervariable ist."
"operator_postfix":::"postincdec_wrong_structure":::"Richtiger Struktur für eine Postfix-Operation: Ein Literal-, Variablen-, Array- oder Methodenzugriff mit einem zurückgegebenen Integer-Typ, dann ein Postfix-Operator (++ oder -) und zuletzt ein Semikolon."
"logic_operators":::"logic_operators_no_operator":::"Der Operator ||, && oder ! muss verwendet werden. Beispiel: true || false."
"logic_operators":::"logic_operators_wrong_numops":::"Dies hat die falsche Anzahl von Operanden. && und || sollten 2 Operanden haben und ! sollte einen Operanden haben."
"logic_operators":::"logic_operators_wrong_type":::"Operanden von logischen Operatoren müssen boolesch sein. Zum Beispiel: true."
"logic_operators":::"logic_operators_wrong_structure":::"Operanden von logischen Operatoren müssen boolesch sein. Beispiel: 3 < 10."
"comparison_operators":::"comparison_operators_no_operator":::"Der Operator <, <=,>,>=, == oder != muss verwendet werden."
"comparison_operators":::"comparison_operators_wrong_numops":::"Es müssen 2 Operanden genutzt werden."
"Vergleichsoperatoren":::"comparison_operators_wrong_type":::"Operanden von Vergleichsoperatoren müssen ganzzahlig oder vom gleichen Typ sein, wenn sie mit == oder != verglichen werden."
"comparison_operators":::"comparison_operators_wrong_structure":::"Operanden von Vergleichsoperatoren müssen ganzzahlig oder vom gleichen Typ sein, wenn sie mit == oder != verglichen werden."
"arithmetic_operators":::"arithmetic_operators_no_operator":::"Der Operator +, -, *, / oder % muss verwendet werden."
"arithmetic_operators":::"arithmetic_operators_wrong_numops":::"Es müssen 2 Operanden genutzt sein."
"arithmetic_operators":::"arithmetic_operators_wrong_type":::"Verwende Operanden vom Typ int, float oder string (für +). Beispiel: 3 + 4"
"arithmetic_operators":::"arithmetic_operators_wrong_structure":::"Verwende Operanden vom Typ int, float oder string (für +). Beispiel: "Hallo" + "Welt!"."
"assignment_operators":::"assignment_operators_no_operator":::"Verwende einen dieser Operatoren: -=, +=, /=, %=, <<=, >>=, >>>=, &=, ^=, oder |=. Zum Beispiel: a += 3; (wenn a eine Integervariable ist). "
"assignment_operators":::"assignment_operators_badLType":::"Verwende eine Variable als linken Operator."
"assignment_operators":::"assignment_operators_wrong_numops":::"Es müssen 2 Operanden vorhanden sein."
"assignment_operators":::"assignment_operators_wrong_type":::"Operanden von Zuweisungsoperatoren müssen vom Typ Integer oder Float sein."
"assignment_operators":::"assignment_operators_wrong_structure":::"Operanden von Zuweisungsoperatoren müssen vom Typ Integer oder Float sein."
"bitwise_operators":::"bitwise_operators_wrong_numops":::"Es müssen 2 Operanden vorhanden sein."
"bitwise_operators":::"bitwise_operators_no_operator":::"Verwende den Operator |, & oder ~. Beispiel: ~ 3."
"bitwise_operators":::"bitwise_operators_wrong_type":::"Verwende Operanden vom Typ Integer. Zum Beispiel 12."
"bitwise_operators":::"bitwise_operators_wrong_structure":::"Die Struktur einer bitweisen Operation lautet: operand op operand für | und & oder: op operand für ~."
lesson: statements
"expressions":::"expression_non":::"Ein Ausdruck besteht aus Variablen, Arrays, Operatoren und Methodenaufrufen."
"statements":::"statement_non":::"Eine Anweisung ist ein Array oder eine Variablendefinition, -Initialisierung oder -Zugriff oder ein Methodenzugriff. Zum Beispiel das Ausdrucken einer 8 mit System.out.println (8); ist eine Anweisung. Andere Beispiel sind Variablen- oder Arrayzuweisungen."
"statements":::"statement_wrong_semicolon":::"Beende eine Anweisung mit einem Semikolon. Beispiel: int a = 9 <b>;</ b>"
"code_blocks":::"codeblock_no_brackets":::"Ein Codeblock muss mit { und } umbrochen werden. Zum Beispiel: {int a; int b}"
"code_blocks":::"codeblock_no_statement":::"Ein Codeblock darf nur Anweisungen enthalten."
lesson: controll_structures
"boolean_expression":::"boolean_expression_non":::"Ein boolescher Ausdruck muss mit true oder false ausgewertet werden können. Zum Beispiel true || 3 < 5 (true ist ein boolesches Literal und 3 < 5 ist gleich true. || is ein boolescher Operator. Deshalb ist true || 3 < 5 ein boolescher Ausdruck. "
"if":::"if_no_keyword":::"Verwende das Schlüsselwort if."
"if":::"if_brackets_not_matching":::"Für jede öffnende runden Klammer muss irgendwann eine schließende runde Klammer verwendet werden."
"if":::"if_no_boolean_expression":::"Jede if-Anweisung muss einen booleschen Ausdruck in runden Klammern enthalten. Zum Beispiel: if(2 * 2 < 9);"
"if":::"if_non_statement":::"Nach dem booleschen Ausdruck muss entweder eine gültige Anweisung oder ein Codeblock folgen. Beispiel: System.out.println("Test");"
"if":::"if_non_codeblock":::"Nach dem booleschen Ausdruck muss entweder eine gültige Anweisung oder ein Codeblock folgen. Beispiel: if(false); oder if(true){}"
"if":::"if_wrong_structure":::"Die if-Anweisung besteht aus 1. dem Schlüsselwort if, 2. einem booleschen Ausdruck umschloßen von runden Klammerm und 3. einer letzten Anweisung oder einem Codeblock. Zum Beispiel: if(true){/*mach etwas*/}"
"while":::"while_no_keyword":::"Jede while-Schleife muss das Schlüsselwort while enthalten. Zum Beispiel: while(true);"
"while":::"while_brackets_not_matching":::"Auf eine öffnende runde Klammer muss irgendwann eine schließende runde Klammer folgen. Zum Beispiel: while ((true));"
"while":::"while_no_boolean_expression":::"Jede while-Anweisung muss einen booleschen Ausdruck in runden Klammern enthalten."
"while":::"while_non_statement":::"Nach dem booleschen Ausdruck muss entweder eine Anweisung oder ein Codeblock stehen."
"while":::"while_non_codeblock":::"Nach dem booleschen Ausdruck muss entweder eine Anweisung oder ein Codeblock folgen."
"while":::"while_wrong_structure":::"Die while-Anweisung besteht aus erstens: dem Schlüsselwort while, zweitens: einem booleschen Ausdruck in runden Klammern und dem drittens: einer Anweisung oder einem Codeblock."
"while":::"while_break":::"Die break-Anweisung kann nur einmal verwendet werden. Zum Beispiel: while(true)break;"
"while":::"while_continue":::"Die continue-Anweisung kann nur einmal verwendet werden: while(true){if(a == 0)continue;}"
"do_while":::"do_while_wrong_semicolon":::"Verwende ein Semikolon nach dem booleschen Ausdruck, um die Schleife abzuschließen. Zum Beispiel: do{}while(true);"
"do_while":::"do_while_no_keyword":::"Jede do while-Schleife muss die Schlüsselwörter do und while enthalten."
"do_while":::"do_while_round_brackets_not_matching":::"Einer schließenden runden Klammer muss irgendwann eine öffnende runde Klammer folgen. Zum Beispiel: do {}whiles((((false)));"
"do_while":::"do_while_curly_brackets_not_matching":::"Jede schließende, geschweiften Klammer muss an einem bestimmten Punkt von in einer öffnenden geschweiften Klammer gefolgt werden. Zum Beispiel: do{{}}while(false);" "
"do_while":::"do_while_no_boolean_expression":::"Jede do while-Anweisung muss einen booleschen Ausdruck in runden Klammern enthalten."
"do_while":::"do_while_non_codeblock":::"Nach dem booleschen Ausdruck muss entweder eine Anweisung oder ein Codeblock folgen."
"do_while":::"do_while_wrong_structure":::"Die do while-Anweisung besteht aus erstens: dem Schlüsselwort do, zweitens: einem Codeblock, drittens: dem Schlüsselwort while und viertens: einem booleschen Ausdruck in runden Klammern und dann zuletzt: einem Semikolon."
"do_while":::"do_while_break":::"Die break-Anweisung kann nur einmal hintereinander verwendet werden. Zum Beispiel: do{break;}while(true);"
"do_while":::"do_while_continue":::"Die continue-Anweisung kann nur einmal hintereinander verwendet werden. do{continue;}while(3 > 2);"
"switch":::"switch_no_keyword":::"Jede switch-Anweisung muss das Schlüsselwort switch enthalten."
"switch":::"switch_round_brackets_not_matching":::"Auf eine öffnende runde Klammer muss irgendwann eine schließende runde Klammer folgen. Zum Beispiel: switch((a)){} (a ist eine Integervariable)"
"switch":::"switch_curly_brackets_not_matching":::"Auf eine öffnende geschweifte Klammer muss irgendwann eine schließende geschweifte Klammer folgen. Beispiel: switch(q){case 0: break;} (b ist eine char-Variable) "
"switch":::"switch_non_variable":::"In den runden Klammern muss eine Variable vom Typ char,byte,short,int,byte oder String stehen. Beispiel: switch(c){} (c ist eine int-Variable). "
"switch":::"switch_wrong_default":::"Ein continue (Standardfall) muss folgendermaßen erstellt werden: default: {/*Codeblock*/} oder default: /*Anweisung*/"
"switch":::"switch_wrong_case":::"Ein case (Fall) muss folgendermaßen aufgebaut sein: case Wert: {/*Codeblock*/} oder case Wert: /*Anweisung*/"
"switch":::"switch_varval_mismatch":::"Variablentyp und Wert müssen übereinstimmen. Beispiel: switch(S){case "tom": break;} (S ist vom Typ String und "tom" ist ein String)"
"switch":::"switch_wrong_structure":::"Die switch-Anweisung besteht aus erstens: dem Schlüsselwort switch, zweitens: einer passenden Variablen in runden Klammern, drittens: einem Codeblock mit cases (Fällen) (und optionalem default (Standartfall))."
"switch":::"switch_break":::"Die break-Anweisung kann nur einmal pro case verwendet werden."
"extended_for":::"extended_for_no_keyword":::"Jede extended for-Schleife muss das Schlüsselwort for enthalten."
"extended_for":::"extended_for_wrong_structure":::"Eine erweiterte for-Anweisung besteht aus den drei Hauptteilen: Erstens dem for-Schlüsselwort, zweitens dem Schleifenkopf und drittens einem Codeblock. Der Schleifenkopf ist folgendermaßen aufgebaut: "Variablendefinition : Array"."
"extended_for":::"extended_for_no_variable_definition":::"In den runden Klammern muss eine Variablendefinition stehen. Beispiel: "int a" zum Durchlaufen eines int-Arrays."
"extended_for":::"extended_for_nonarray":::"In den runden Klammern muss ein Zugriff auf ein vorhandenes Array stehen."
"extended_for":::"extended_for_varar_mismatch":::"Das Array und die Variablendefinition in der runden Klammer müssen vom gleichen Typ sein. Zum Beispiel: eine Stringvariable s zum Durchlaufen des String-Arrays S: for(String s: S);"
"extended_for":::"extended_for_break":::"Die break-Anweisung kann nur einmal nacheinander verwendet werden."
"extended_for":::"extended_for_continue":::"Die continue-Anweisung kann nur nacheinander einmal verwendet werden."
"extended_for":::"extended_for_noncode_block":::"Du musst einen gültigen Codeblock oder eine gültige Anweisung verwenden."
"extended_for":::"extended_for_nonstatement":::"Du musst einen gültigen Codeblock oder eine gültige Anweisung verwenden."
"for":::"for_no_keyword":::"Jede for-Schleife muss das Schlüsselwort for enthalten."
"for":::"for_wrong_structure":::"Eine for-Schleife besteht aus den 3 Hauptteilen. Erstens dem for-Schlüsselwort, zweitens dem Schleifenkörper, drittens einem Codeblock oder einer Anweisung. Der Schleifenkörper besteht wiederum aus 3 Teilen, welche alle optional sind: erstens: eine Variablendefinition und -initialisierung, eine Neuzuweisung oder nur eine Anweisung, zweitens: ein boolescher Ausdruck, drittens: eine Neuzuweisung oder eine Anweisung."
"for":::"for_no_variable_definition":::"Der erste Element in den runden Klammern der for-Schleife muss eine Variablendefinition, -initialisierung oder -zuweisung oder nichts enthalten."
"for":::"for_no_boolean_expression":::"Der zweite Teil in den runden Klammern der for-Schleife muss leer oder ein boolescher Ausdruck sein."
"for":::"for_no_increment":::"Der dritte Teil in den runden Klammern der for-Schleife muss leer sein, eine Zuweisungsoperation oder eine Anweisung sein."
"for":::"for_break":::"Die break-Anweisung kann nur einmal nacheinander ausgeführt werden."
"for":::"for_continue":::"Die continue-Anweisung kann nur einmal nacheinander ausgeführt werden."
"for":::"for_noncode_block":::"Eine for-Anweisung muss entweder einen gültigen Codeblock oder eine gültige Anweisung haben."
"for":::"for_nonstatement":::"Eine for-Anweisung muss entweder einen gültigen Codeblock oder eine gültige Anweisung haben."
lesson: arrays
"array_definition":::"array_definition_no_brackets":::"Array-Definitionen müssen [] enthalten. Zum Beispiel: int[] a;"
"array_definition":::"array_definition_wrong_structure":::"Eine Arraydefinition sieht wie folgt aus: int Name[]; oder der int Name[];."
"array_definition":::"array_definition_non_identifier":::"Jeder Arrayname muss ein gültiger Bezeichner sein."
"array_definition":::"array_definition_non_type":::"Eine Variablendefinition muss einen bekannten Typ haben. Zum Beispiel: boolean"
"array_definition":::"array_definition_name_double":::"Jedes definierte Array muss einen eindeutigen Bezeichner haben."
"array_definition":::"array_definition_wrong_semicolon":::"Eine Variablendefinition muss mit einem Semikolon enden."
"array_definition_initialization":::"array_definition_initialization_no_brackets":::"Für eine Arraydefinitionen und -initialisierungen muss eine Werteliste in geschweiften Klammern angegeben werden. Zum Beispiel: int[] example = {1,2,3};"
"array_definition_initialization":::"array_definition_initialization_wrong_semicolon":::"Eine Arraydefinition muss ein Semikolon beenden."
"array_definition_initialization":::"array_definition_initialization_name_double":::"Jeder Arrayname muss eindeutig sein."
"array_definition_initialization":::"array_definition_initialization_non_type":::"Falscher Typ. Eine Arraydefinition und -initialisierung muss einen primitiven Typ oder einen benutzerdefinierten Typ enthalten."
"array_definition_initialization":::"array_definition_initialization_typemismatch_integer":::"Der Typ in der Array-Definition muss mit dem Typ der zugewiesenen Werte (Ganzzahl) übereinstimmen."
"array_definition_initialization":::"array_definition_initialization_typemismatch_float":::"Der Typ in der Array-Definition muss mit dem Typ der zugewiesenen Werte übereinstimmen (float)."
"array_definition_initialization":::"array_definition_initialization_typemismatch_boolean":::"Der Typ in der array_definition muss mit dem Typ der zugewiesenen Werte übereinstimmen (boolean)."
"array_definition_initialization":::"array_definition_initialization_typemismatch_char":::"Der Typ in der array_definition muss mit dem Typ der zugewiesenen Werte (char) übereinstimmen."
"array_definition_initialization":::"array_definition_initialization_typemismatch_string":::"Der Typ in der array_definition muss mit dem Typ der zugewiesenen Werte (String) übereinstimmen."
"array_definition_initialization":::"array_definition_initialization_wrong_type":::"Der Typ in der Arraydefinition muss mit dem Typ des zugewiesenen Werts übereinstimmen. Beispiel: int a[] = {1,2} (1 und 2 sind beide vom Typ int ). "
"array_definition_initialization":::"array_definition_initialization_wrong_structure":::"Eine Arraydefinition und -initialisierung muss wie eine Arraydefinition ohne; aussehen und von {value1, ..., valueN}; gefolgt werden. Zum Beispiel: int a[] = {1,5,7};"
"array_definition_initialization":::"array_definition_initialization_typeclass_no_new":::"Dies enthält nicht das Schlüsselwort new."
"array_definition_initialization":::"array_definition_initialization_typemismatch_class":::"Der Typ auf der linken Seite stimmt nicht mit dem Typ auf der rechten Seite überein."
"array_definition_initialization":::"array_definition_initialization_contructor_parameter_mismatch":::"Dies ist keine gültige Arraydefinition und -initialisierung. Die Parameter stimmen nicht mit den im Konstruktor definierten Parametern überein."
"array_definition_initialization":::"array_definition_initialization_contructor_parameter_mismatch_len":::"Dies ist keine gültige Arraydefinition und -initialisierung. Die Anzahl der Parameter in der Konstruktordefinition stimmt nicht mit der Anzahl der in der Deklaration verwendeten Parameter überein."
"array_declaration":::"array_declaration_no_brackets":::"Eine Arraydeklarationen muss ein [ und ein ] haben."
"array_declaration":::"array_declaration_no_new":::"Eine Arraydeklarationen müssen das Schlüsselwort new haben."
"array_declaration":::"array_declaration_wrong_semicolon":::"Eine Arraydeklaration muss mit einem Semikolon enden."
"array_declaration":::"array_declaration_name_double":::"Jeder Arrayname muss ein eindeutiger Bezeichner sein."
"array_declaration":::"array_declaration_non_type":::"Eine Arraydeklaration und -Initialisierung muss einen primitiven Typen oder einen benutzerdefinierten Typen enthalten. Zum Beispiel int: int[] a = new int[];"
"array_declaration":::"array_declaration_wrong_type":::"Der Typ in der Arraydeklaration muss mit dem Typ des zugewiesenen Werts übereinstimmen."
"array_declaration":::"array_declaration_wrong_structure":::"Eine Arraydeklaration muss folgendermaßen aussehen: Typ[] name = new type[elements];"
"array_declaration":::"multidim_array_declaration_wrong_structure":::"Eine Array-Deklaration muss folgendermaßen aussehen: Typ [] ... [] name = new type [dimension1] ... [dimensionN];."
"array_declaration":::"multidim_array_declaration_bracketnumber_not_matching":::"Eine Arraydeklaration muss folgendermaßen aussehen: type [] ... [] name = new Typ[Dimension1] ... [DimensionN];. Die Anzahl der [] auf der linekn Seite des = muss mit der Anzahl der [] auf der rechten Seite übereinstimmen (die Zahl [] gibt die Anzahl der Dimensionen an). "
"array_reassignment":::"array_reassignment_unknown_array":::"Ein Array muss definiert und deklariert bzw. initialisiert werden, bevor benutzt werden kann."
"array_reassignment":::"array_reassignment_wrong_structure":::"Die Struktur für eine Neuzuweisung lautet: arrayname[index] = value;"
"array_reassignment":::"array_reassignment_non_type":::"Eine Variablendefinition und -initialisierung enthält keinen primitiven oder benutzerdefinierten Typ."
"array_reassignment":::"array_reassignment_non_identifier":::"Der Arrayname muss ein gültiger Bezeichner sein."
"array_reassignment":::"array_reassignment_wrong_semicolon":::"Eine Array-Neuzuweisung muss mit einem Semikolon enden."
"array_reassignment":::"array_reassignment_name_double":::"Jeder Arrayname muss eindeutig sein."
"array_reassignment":::"array_reassignment_wrong_type":::"Der Typ in der Arraydefinition stimmt nicht mit dem Typ des zugewiesenen Werts überein. Wenn beispielsweise a ein int-Array ist: a[0] = 9; richtig, weil 9 vom Typ int ist.
"array_reassignment":::"array_reassignment_typemismatch_integer":::"Der Typ in der Array-Definition muss mit dem Typ des zugewiesenen Werts (int) übereinstimmen. Wenn beispielsweise a ein int-Array ist, ist a[0] = 3; richtig, weil 3 vom Typ int ist."
"array_reassignment":::"array_reassignment_typemismatch_float":::"Der Typ in der Array-Definition muss mit dem Typ des zugewiesenen Werts (float) übereinstimmen. Wenn beispielsweise a ein double Array ist: ist a[0] = 3.0D; richtig , weil 3.0D ein double Literal ist."
"array_reassignment":::"array_reassignment_typemismatch_boolean":::"Der Typ in der Array-Definition muss mit dem Typ des zugewiesenen Werts (boolean) übereinstimmen. Wenn a beispielsweise ein boolesches Array ist, ist a[0] = 3<2; richtig, weil 3<2 vom booleschen Typ ist. "
"array_reassignment":::"array_reassignment_typemismatch_char":::"Der Typ in der Array-Definition muss mit dem Typ des zugewiesenen Werts (char) übereinstimmen. Wenn beispielsweise a ein int-Array ist, ist a[0] = 'a'; richtig, weil 'a' vom Typ char ist. "
"array_reassignment":::"array_reassignment_typemismatch_string":::"Der Typ in der Array-Definition muss mit dem Typ des zugewiesenen Werts (String) übereinstimmen. Wenn beispielsweise a ein String-Array ist, ist a [0] = "element"; richtig, weil "element" vom Typ String ist. "
"array_reassignment":::"array_reassignment_typeclass_no_new":::"Die Array-Definition und -Initialisierung muss das Schlüsselwort new enthalten, wenn ein benutzerdefinierter Typ deklariert wird."
"array_reassignment":::"array_reassignment_typemismatch_class":::"Der Typ auf der linken Seite muss mit dem Typ auf der rechten Seite übereinstimmen."
"array_reassignment":::"array_reassignment_contructor_parameter_mismatch":::"Die Parameter stimmen nicht mit den im Konstruktor definierten Parametern überein."
"array_reassignment":::"array_reassignment_contructor_parameter_mismatch_len":::"Die Anzahl der Parameter in der Konstruktordefinition stimmt nicht mit der Anzahl der in der Deklaration verwendeten Parameter überein."
"array_reassignment":::"array_reassignment_wrong_dim":::"Der Index in der Array-Neuzuweisung muss mit der definierten Dimension in der Array-Deklaration übereinstimmen."
"array_access":::"array_access_wrong_structure":::"Ein Array-Zugriff besteht aus zwei Teilen: dem Array-Namen und einem gültigen Index, der von [] eingeschlossen ist. Beispiel: ar[2]."
"array_access":::"array_access_unknown_array":::"Jedes Array, auf das du zugreifen möchtest, muss zuerst definiert und initialisiert bzw. deklariert werden."
"array_access":::"multidim_array_access_unknown_array":::"Jedes Array, auf das du zugreifen möchtest, muss zuerst definiert und initialisiert bzw. deklariert werden."
"array_access":::"array_access_no_declaration":::"Jedes Array, auf das Sie zugreifen möchtest, muss zuerst definiert und initialisiert bzw. deklariert werden."
"array_access":::"array_access_outofrange":::"Ungültiger Index. Der Index ist kleiner als 0 oder größer als das Array."
"multidim_array_definition":::"multidim_array_definition_no_brackets":::"Eine multidimensionale Array-Definition muss [] enthalten."
"multidim_array_definition":::"multidim_array_definition_wrong_semicolon":::"Eine multidimensionale Array-Definition muss mit einem Semikolon enden."
"multidim_array_definition":::"multidim_array_definition_name_double":::"Jedes Array muss einen eindeutigen Bezeichner haben."
"multidim_array_definition":::"multidim_array_definition_non_identifier":::"Der Arrayname muss ein gültiger Bezeichner sein."
"multidim_array_definition":::"multidim_array_definition_non_type":::"Diese Array-Definition muss von einem primitiven Typ oder einem benutzerdefinierten Typ sein."
"multidim_array_definition":::"multidim_array_definition_wrong_structure":::"Eine Arraydefinition sieht wie folgt aus: Typ[] ... [] name; oder Typ name [] ... []; "
"multidim_array_declaration":::"multidim_array_declaration_bracketnumber_not_matching":::"Die Anzahl der eckigen Klammern auf der linken Seite muss mit der Anzahl der eckigen Klammern auf der rechten Seite übereinstimmen."
"multidim_array_declaration":::"multidim_array_declaration_wrong_structure":::"Die Struktur der Array-Deklaration ist falsch. Sie muss folgendermaßen aussehen: Typ[] ... [] name = new Typ[dimension1] ... [dimensionN];."
"multidim_array_access":::"multidim_array_access_unknown_array":::"Jedes Array, auf das zugegriffen wird, muss zuerst definiert und deklariert werden."
"multidim_array_access":::"multidim_array_access_no_declaration":::"Jedes Array, auf das zugegriffen wird, muss zuerst definiert und deklariert werden."
"multidim_array_access":::"multidim_array_access_outof_dim":::"Auf ein Array kann nur mit den richtigen Indezes zugegriffen werden. Zum Beispiel: Auf das Array int a[][] = new int[2][2] kann nur mit zugegriffen werden den folgenden Indezes: a[0][0], a[0][1], a[1][0] oder a[1][1]."
"multidim_array_access":::"multidim_array_access_wrong_structure":::"Ein Array-Zugriff sieht wie folgt aus: Arrayname[Dimension1] ... [DimensionN]. Zum Beispiel: a[0][0] für das zweidimensionale Array a."
"multidim_array_access":::"multidim_array_access_oof":::"Jeder Index in einer Array-Neuzuweisung muss über 0 und unter dem in der Array-Deklaration definierten Bereich (Dimension) liegen."
"multidim_array_reassignment":::"multidim_array_reassignment_unknown_array":::"Jedes Array, auf das du zugreifen möchtest, muss zuerst definiert und initialisiert bzw. deklariert werden."
"multidim_array_reassignment":::"multidim_array_reassignment_no_declaration":::"Das Array wurde definiert, aber nicht deklariert bzw. initialisiert und kann daher nicht verwendet werden."
"multidim_array_reassignment":::"multidim_array_reassignment_outof_dim":::"Eine Array-Neuzuweisung muss einen gültigen Index (<0 oder> definierter Index) enthalten."
"multidim_array_reassignment":::"multidim_array_reassignment_wrong_structure":::"Eine Array-Neuzuweisung besteht aus zwei Teilen: Array-Zugriff und dann eine Zuweisung. Zum Beispiel a[0][1] = 2.1;"
"multidim_array_reassignment":::"multidim_array_reassignment_oof":::"Jeder Index in einer Array-Neuzuweisung muss über 0 und unter dem in der Array-Deklaration definierten Bereich liegen."
lesson: methods
"method_definition":::"method_definition_no_identifier":::"Methodennamen müssen gültige Bezeichner sein."
"method_definition":::"method_definition_wrong_return":::"Der Rückgabetyp muss mit dem im Methodenkopf definierten Rückgabetyp übereinstimmen."
"method_definition":::"method_definition_wrong_type":::"Der Rückgabetyp einer Methode kann ein primitiver Typ, ein benutzerdefinierter Typ oder void sein."
"method_definition":::"method_definition_wrong_modifier":::"Der Methodenmodifier muss statisch oder ein Zugriffsmodifier (öffentlich, privat oder geschützt) sein."
"method_definition":::"method_definition_wrong_variable_definition":::"Alle Variablendefinitionen in runden Klammern müssen gültig sein."
"method_definition":::"method_definition_wrong_structure":::"Eine Methodendefinition besteht aus zwei Hauptteilen: dem Kopf und einem Codeblock. Der Kopf besteht aus optionalen Methodenmodifikatoren, einem Rückkehrtyp, einem Methodennamen und einer Parameterdefinition. Zum Beispiel: void test(){}"
"method_modifiers":::"method_defintion_no_mod":::"Verwende einen dieser Modifikatoren: public, private, protected oder static."
"method_access":::"method_access_wrong_structure":::"Ein Methodenzugriff besteht aus einem Methodennamen und anschließend einer Parameterliste und einem Semikolon. Beispiel: div(1,2);"
"method_access":::"method_access_unknown_method":::"Unbekannter Methodenname. Die Methode muss definiert werden, bevor sie aufgerufen werden kann."
"method_access":::"method_access_parameter_mismatch":::"Alle Parameter im Methodenzugriff müssen mit den Parameterdefinitionen in der Methodendefinition übereinstimmen."
lesson: classes
"class_definition":::"class_definition_no_keyword":::"Eine Klassendefinition muss das Schlüsselwort class enthalten."
"class_definition":::"constructor_definition_wrong_name":::"Der Name des Konstruktors muss mit dem Namen seiner Klasse identisch sein."
"class_definition":::"constructor_definition_wrong_modifier":::"Falscher Modifier: Nur public, protected und private sind erlaubt."
"class_definition":::"constructor_wrong_structure":::"Falsche Struktur für Konstruktor! Die Struktur eines Konstruktors lautet: Modifikator Klassenname(parameterliste){/*code block*/}."
"class_definition":::"constructor_wrong_body":::"Der Körper des Konstruktors muss ein gültiger Methodenkörper sein. Zum Beispiel: {}"
"class_definition":::"class_definition_no_mod":::"Kein Modifikator! Bitte verwende den Modifikator static, abstract oder final."
"class_definition":::"class_definition_name_double":::"Jeder Klassenname kann nur einmal verwendet werden."
"class_definition":::"class_definition_no_curly_brackets":::"Eine Klassendefinition muss einen von geschweiften Klammern eingerahmten Klassenkörper enthalten. Beispiel: class Test{}"
"class_definition":::"class_definition_invalid_identifier":::"Der Klassenname muss ein gültiger Bezeichner sein."
"class_definition":::"class_definition_invalid_accessmodifier":::"Die Zugriffsmodifier der Klasse müssen gültig sein (public, private, protected)."
"class_definition":::"class_illegal_classblock":::"Ein Klassentext kann nur Variablen- und Methodendefinitionen enthalten."
"class_definition":::"class_definition_wrong_structure":::"Eine Klassendefinition hat die Syntax: optional_access_modifier optional_modifier Klassenname {/ * optional: classmembers * /}"
"access_modifiers":::"class_definition_no_access_mod":::"Nur öffentliche, private oder geschützte sind erlaubt."
"class_modifiers":::"class_definition_no_mod":::"Es wurde kein oder ein falscher Modifikator verwendet: $. static, abstract und final sind erlaubt."
"inheritance":::"inheritance_non_parent":::"Jede untergeordnete Klasse muss eine gültige übergeordnete Klasse haben."
"inheritance":::"inheritance_wrong_structure":::"Die richtige Struktur für eine Vererbung sieht folgendermaßen aus: class child_class extended parent_class {/ * class_body * /}."
"member_access_variables":::"member_access_variables_unknown_object":::"Jedes Objekt muss definiert und deklariert werden, bevor darauf zugegriffen werden kann."
"member_access_variables":::"member_access_variables_unknown_member":::"Die Membervariable muss in der Klassendefinition definiert werden."
"member_access_variables":::"member_access_variables_wrong_structure":::"Rechtes Format für den Zugriff auf Mitglieder: object.member;"
"member_access_methods":::"member_access_methods_unknown_object":::"Jedes Objekt muss definiert und deklariert werden, bevor auf es zugegriffen werden kann."
"member_access_methods":::"member_access_methods_unknown_member":::"Jede Member-Methode muss in der Klassendefinition definiert werden, bevor sie verwendet werden kann."
"member_access_methods":::"member_access_methods_wrong_structure":::"Richtiges Format: object.membermethod(parameter_list);"