lesson: programm_structure
"programm_structure_main":::"Der Einstiegspunkts einer Java-Anwendung ist die sogenannte Main-methode. Jede Java-Anwendung muss eine Main-methode mit folgendem Aufbau haben: public static void main(String a []){}. In geschweiften Klammern kannst du den Code schreiben, den du ausführen möchtest. Es könnte beispielsweise ein System.out.println("Hello") sein. System.out.println() gibt einen String auf der Konsole aus und "Hello" ist das, was du ausgeben möchten."
"programm_structure_import":::"Der Code anderer Java-Dateien kann in deinem Programm verwendet werden. Dies wird durch eine Importdeklaration erreicht. Eine Importdeklaration importiert Code (der sich auf deinem Computer befindet), indem ein Pfad zu den entsprechenden Java-Dateien angegeben wird. Du kannst den Code dann verwenden, indem du einen einfachen Namen statt des vollständigen Pfads zu dem Ordner verwendest, der das Paket enthält. Importdeklarationen müssen nach der Packagedeklaration am Anfang einer Java-Datei geschrieben werden. Das siehst folgendermaßen aus: import identifier[.identifier]*; (Das * bedeutet, dass der Teil in [] wiederholt werden kann). Ein Bezeichner ist vorerst nur ein Name wie "java" oder "math". Hier ein Beispiel: import java.util.Random; (java ist ein Paket, welches util enthält, welches wiederum die Klasse Random enthält).". Du kannst * als Platzhalter hinzufügen, um jeden Pfad zu importieren, der gegen * ausgetauscht werden kann. Zum Beispiel würde "import java.util.*;"  alles importieren, was in util gespeichert ist (einschließlich java.util.Random)."
"programm_structure_packages":::"Ein Packagedeklaration (Paketdeklaration) wird verwendet, um Java-Dateien in ein Paket zu binden, welches importiert werden kann. Eine Packagedeklaraion siehst aus wie eine importdeklaration, mit dem Unterschied, dass es keine Platzhalter gibt und du diese mit "package" beginnst. Ein Package wird ganz am Anfang deklariert, also am Anfang der Java-Datei (z.B. package application.mylibrary;)."
lesson: basics
"comments":::"Ein Kommentar wird vom Compiler nicht übersetzt und ist für die Leser des Quellcodes bestimmt; zum Beispiel zur Erläuterung eines Codebereichs (was dieser tut, warum usw.). \nEs gibt drei Arten von Kommentaren: \n- Einzeilige Kommentare: Sie beginnen an einem beliebigen Punkt einer Zeile und markieren den Rest der Zeile als Kommentar. Sie werden mit einem // (z. B. // Hallo) eingeleitet \n-Mehrzeilenkommentare: Sie können an jeder beliebigen Stelle in einer Zeile beginnen und so viele Zeilen umfassen, wie du möchtest. Du beginnst mit einem /* und endest mit einem */. \n- Java-Doc: Sie werden wie mehrzeilige Kommentare erstellt und stehen über einer Klasse oder Methode, um diese zu erklären. \nKommentare können andere Kommentare enthalten, aber jeder Kommentar muss korrekt beginnen und abgeschlossen sein. Daher ist /* \n// \n*/ legal, während /*//*/ ist nicht legal ist (weil das */ nicht erkannt wird)."
"literals":::"Ein Literal ist die Quellcodedarstellung eines Werts eines primitiven Typs oder des Nulltyps (leerer Wert). Literale können also Zahlen (4 oder 4.2), Zeichen ('a') oder Zeichenfolgen  ("Hallo"), boolesche Werte (wahr und falsch) oder der leere Wert null sein."
"integer_literals":::"Integer-Literale sind Ganzzahlen (z.B.: -143). Du kannst sie in vier Basen schreiben: \n1. binär: 0b gefolgt von einer Binärzahl (die Ziffern 0 und 1). z.B.: 0b11 \n2 oktal: 0, gefolgt von einer Oktalzahl (Ziffern von 0 bis 7), z.B.: 01245 \n3. hexadezimal 0x, gefolgt von einer hexadezimalen Zahl (Ziffern von 0 bis 9 und Buchstaben A bist F), z.B.: 0xA31F \n4. dezimal (Ziffern von 0 bis 9)."
"floating-point_literals":::"Gleitkommazahlen-Literale stellen Bruchzahlen dar (z.B.: 1.43). Es gibt zwei Typen: float und double. float-Literale werden mit einem Dezimalbruch (z.B. 1.2), gefolgt einem optionalen Exponenten-Indikator geschrieben, gefolgt von F (z.B. 15.3E4F = 153000.0). double-Literale können ein optionales D anstelle eines F (z.B. 2.21E3D = 2210.0) enthalten. Der erste Teil von Gleitkommazahlen-Literalen (vor dem.) und der zweite Teil (nicht beide) sind optional und als Standart eine 0 angenommen wird (z.B. 1F = 0.F, 1D = 1.0).
"character_literals":::"Characterliterale (Zeichenliterale) sind alle ASCII-Zeichen und werden mit ' umhüllt (z.B.:'a'oder '$'). Characterliterale können dem Typ char zugeordnet werden (z.B. char a = 'a'). Es gibt Sonderzeichen, welche keine sichtbaren Zeichen sind, aber eine Funktion haben (z.B. '\\n' ist ein Zeilenumbruch): \'(einfaches Anführungszeichen), \"(doppeltes Anführungszeichen), \\ (umgekehrter Schrägstrich), \t (Tabulator) ), \b (Rücktaste), \r (Wagenrücklauf), \f (Formfeed)."
"string_literals":::"String-Literale sind Strings, sie bestehen also aus einer Folge von Zeichen (z.B. Stringtest = "Hallo"). Strings können mit + verkettet werden (z.B."zwei " + "Wörter" entspricht dem String "zwei Wörter")."
"boolean_literals":::"Boolesche Literale sollen die Gültigkeit einer Aussage widerspiegeln, welche wahr oder falsch sein kann. Es gibt also die booleschen Literale true(wahr) und false(falsch). Vergleiche basieren auf einem booleschen Wert (z.B. 3 < 9 ist true, 3 > 9 ist false).
"null_literal":::"Das Literal null kennzeichnet die Abwesenheit eines Wertes (es ist eine leere Speicherreferenz). Es kann einer Variablen eines beliebigen Typs (z. B. int a = null;) zugewiesen werden, um diesen zu markieren. Wenn eine Variable mit einer Nullreferenz gelesen werden soll, wird eine NullPointerException (ein Fehler) erzeugt. null wird verwendet um zu prüfen, ob eine Variable bereits initialisiert wurde (dies wird mit var == null getan)."
"keywords":::"Ein Schlüsselwort ist eine reservierte Zeichenfolge mit einer Semantik die in der Sprache definiert wurde. Bei Schlüsselwörtern wird zwischen Groß- und Kleinschreibung unterschieden. Zu den Schlüsselwörtern gehören: abstract, continue, for, new, switch, assert, default, if, package, synchronized, boolean, do, goto, private, this, break, double, implements, protected, throw, byte, else, import, public, throws, case, enum, instanceof, return, transient, catch, extends, int, short, try, char, final, interface, static, void, class, finally, long, strictfp, volatile, const, float, native, super and while."
"identifiers":::"Ein Bezeichner ist ein Name, der auf etwas im Code verweist (eine Variable, eine Methode, eine Klasse ...). Bei Bezeichnern in Java wird die Groß- und Kleinschreibung beachtet. Ein Bezeichner kann Folgendes enthalten: \nJedes Unicode-Zeichen welches ein Buchstabe ist (einschließlich numerischer Buchstaben wie römische Ziffern) oder Ziffern. \n- Das Währungszeichen (wie z. B. $). \n- Der Unterstrich (wie z. B. _). \nAber ein Bezeichner kann nicht: \n1. Mit einer Ziffer beginnen oder \n2. Einem reservierten Schlüsselwort, null, true oder false entsprechen \n3. Es dürfen nicht zwei identische Bezeichner für verschiedene Strukturen benutzt werden."
"types":::"Daten werden in verschiedenen Formen gespeichert, die als Typen bezeichnet werden. Die Daten, die einem bestimmten Typ entsprechen, können etwas in der Realität oder einer Idee darstellen. Beispielsweise können 3 Strings (Name, Nachname und Adresse) eine Identifikation für eine Person sein oder 3 Ganzzahlen können eine Farbe im RGB-Format darstellen. Was ich gerade beschrieben habe, sind benutzerdefinierte Typen. Es gibt jedoch auch eingebaute Typen (die als Bausteine ​​für benutzerdefinierte Typen verwendet werden können. Die eingebauten Typen werden als primitive Typen bezeichnet. Es gibt Typen für Integer (ganze Zahlen): char, int, long, short und byte, die sich im Bereich der von ihnen darstellbaren Zahlen unterscheiden. Gleitkommazahlen: float und double. double kann einen breiteren Bereich von Zahlen darstellen. Der Typ char kann auch Zeichen darstellen und der Typ String stellt Strings (Zeichenfolgen) dar. Der Typ boolean stellt die Werte true und false dar. \nHier sind die Bereiche für die verschiedenen Ganzzahlentypen: \n• Für Byte, von - 128 bis 127 \n• short, von -32768 bis 32767 \nFür int, von -2147483648 bis 2147483647 \nlong, von -9223372036854775808 bis 9223372036854775807 \n• Für char, von '\ u0000' bis '\ uffff' einschließlich, dh von 0 bis 65535."
"variable_definition":::"Variablen können zum Speichern von Daten bzw. Werten verwendet werden (z.B. von Literalen). Variablen haben einen Namen, einen Typ und einen Wert, der diesem Typ zugeordnet ist. So kann beispielsweise eine int Variable ein Integerliteral speichern. Sie werden durch schreiben des Variablentyps, dann des Variablennamens und zuletzt eines Semikolons definiert. Beispiel: int var;"
"variable_definition_initialization":::"Eine Variable kann in derselben Anweisung definiert und initialisiert werden, indem ein Wert zugewiesen wird, der dem Typ entspricht (z.B.: int a = 9;)."
"variable_access":::"Auf eine zuvor definierte Variable kann mit deinem Bezeichner zugegriffen werden. \n Hier ist ein Beispiel: Definition einer Variablen (int a;) und anschließender Zugriff (Ausgabe mit System.out.println();: System.out.println(a);)."
"variable_reassignment":::"Eine Variable kann neu zugewiesen werden, indem ein passendes Literal, eine Variable, die Rückgabe einer Methode oder ein Array-Element desselben Typs zugewiesen wird."
lesson: arrays
"array_definition":::"Arrays enthalten eine Folge von Variablen desselben Typs. Sie haben immer eine feste Größe. So kann ein integer array der Größe 3, 3 integer speichern. Arrays werden wie folgt definiert: typ name[]; oder so: typ []name;. Es gibt absolut keinen Unterschied zwischen diesen beiden Varianten. Bevor sie verwendet werden können, müssen sie deklariert werden (die Anzahl der Elemente muss festgelegt werden). Ein Element eines Arrays kann wie eine "normale" Variable desselben Typs verwendet werden. "
"array_declaration":::"Eine Array-Deklaration beschreibt, wie viele Elemente ein Array enthält, und initialisiert sie mit einem Standardwert (0 für Zahlen, der leere String für Strings, das leere Zeichen für char, true für Booleans oder null für andere Typen). Nach der Array-Deklaration kannst du das Array verwenden (Lesen und Schreiben). Du kannst zuerst ein Array definieren und es dann wie folgt deklarieren: typ Arrayname;  und dann deklarieren: Arrayname = neuer Typ [Elemente]; (z. B. int []a; a = new int [3];). \nDu können dies aber auch in einem Schritt tun: type[] name = new type[größe]; (z.B. int y[] = new int[2]; - ​​dies erzeugt das Array y mit 2 Elementen) (Hinweis: Die Indizes beginnen bei 0. Das heißt, y hat zwei Elemente: y [0] und y [1])."
"array_definition_initialization":::"Arrays können mit benutzerdefinierten Werten in einem Schritt wie folgt definiert, deklariert und initialisiert werden: typ name[] = {value1, ..., valueN} (z.B. int a[] = {1,2,3};). Diese Initialisierung kann nur einmal zusammen mit der Definition durchgeführt werden."
"array_access":::"Auf Arrays wird folgendermaßen zugegriffen: name[index] (z.B. y[0])."
"array_reassignment":::"Ein einzelnes Element eines Arrays kann folgendermaßen ein neuer Wert zugewiesen werden: type[index] = wert; (z.B. name[3] = "hans";)."
"multidim_array_definition":::"Ein multidimensionales Array ist ein Array, das ein Array oder Arrays von Arrays oder Arrays von Arrays von Arrays enthält u.s.w.. Ein zweidimensionales Array besteht beispielsweise aus einem Array von Arrays. Das bedeutet, dass Arrayelemente in der ersten Dimension ein eindimensionales Array hat. In Java werden mehrdimensionale Arrays wie folgt definiert: typ name[]...[]; oder typ []...[]name; (z.B. int [][]a; für ein zweidimensionales Array). Hier ein Beispiel: Ein Array mit der Größe 1920 * 1080 hat 1920 Elemente in der ersten Dimension. Jedes Element der ersten Dimension hat ein Array mit 1080 Elementen. Ein Array wie dieses könnte verwendet werdem um ein Full-HD-Bild zu beschreiben - jedes Element dieses Arrays würde ein Pixel darstellen."
"multidim_array_declaration":::"Das multidimensionale Array kann folgendermaßen deklariert werden: type []...[] name = new type [dimension1] ... [dimensionN]; (z.B. int [][]numbers = new int[3][3]; - dies erzeugt das Array y mit 3 * 3 int's."
"multidim_array_access":::"Auf multidimensionale Arrays wird folgendermaßen zugegriffen: name[index1] ... [indexN] (z.B. int a[][] = new int[2][2]; a [0][1] ist 0.)
"multidim_array_reassignment":::"Syntax für die Neuzuweisung: name[Index1]...[IndexN] = Wert; (z.B. a[0][0] = 1;)."
lesson: operators
"arithmetic_operators":::"Arithmetische Operatoren können Integerliteral und Gleitkommazahlenliterale verbinden, + kann zusätzlich zur Verkettung von Strings verwendet werden. + entspricht Addition von Zahlen, - entspricht Subtraktion, * entspricht Multiplikation, / entspricht Division, % entspricht Modulo. Modulo ist der Rest aus einer ganzzahligen Division (z.B. 2 % 4 ist gleich 2, weil 2/4 0 ist, mit einem Rest von 2 (2 = 4 * 0 + 2). Ein zweites Beispiel: 5 % 4 ist 1, weil 5/4 ist 1, Rest 1 (5 = 1 * 4 + 1)."
"operators_prefix":::"Inkrementieren bedeutet in Java, 1 auf etwas zu addieren, dekrementiert bedeutet 1 von einer Ganzzahl zu subtrahieren. Um eine Variable von Ganzzahltypen (int, long, short, byte oder char) zu inkrementieren, nutzen wird den Inkrementierungsoperator ++ und um eine Variable zu dekrementieren, kann der Dekrementierungsoperator -- verwendet werden (z.B. ++a ist gleich a + 1, --a ist gleich a - 1). Wenn ein Inkrementierungs- oder Dekrementierungsoperator vor einer Variablen steht, wird der Wert erst inkrementiert oder dekrementiert und dann der Variablen zugewiesen (z.B. ++a oder --a). Wenn ++ oder -- vor eine Variable geschrieben werden, werden sie Präfixoperatoren genannt. "
"operators_postfix":::"Der Inkrementierungs- oder Dekrementierungsoperator kann hinter eine Variable geschrieben werden (z. B. a++). Wenn sie nach einer Variablen geschrieben werden, wird die Variable zuerst zugewiesen und dann inkrementiert. Beispiel: Wenn die int-Variable a 3 ist , System.out.println (a++); druckt 3 aus, weil a zugewiesen und dann inkrementiert wird. Das bedeutet, dass ein zusätzliches System.out.println(a); 4  ausgeben würde. Wenn ++ oder -- nach einer Variablen geschrieben werden, werden sie als Postfix-Operatoren bezeichnet."
"comparison_operators":::"Vergleichsoperatoren können zum vergleichen von Zahlen verwendet werden. Kleiner als: <, größer als: >, kleiner-gleich: <=, größer-gleich: >=, ungleich: != und gleich: ==, werden verwendet um Zahlen zu vergleichen und ein boolesches Literal zurückzugeben. == und != können auch jeden anderen Typ oder Null vergleichen, solange beide Operanden vom gleichen Typ sind. \nEs ist wichtig zu verstehen, dass in java = kein Vergleich ist , aber eine Zuweisung. == ist der Gleichheitsoperator in Java. "
"logic_operators":::"Logikoperatoren können Operanden mit den booleschen Werten "true" oder "false" kombinieren. Als Operanden sind nicht nur die Literale true und false zulässig, sondern auch Variablen vom Typ boolean, boolesche Ausdrücke, Methoden, die true oder false zurückgeben oder  Vergleichsoperationen.! ist das logische NICHT (z.B.! (3 < 9) ergibt false), && ist das logische UND (z.B. (!true) && true ergibt false), || ist das logische OR (z.B. true |) | false wird zu true ausgewertet, true || true ist true) und ^ ist das logische XOR (true ^ false ist true). Die AND-Operation wird nur dann zu true ausgewertet, wenn BEIDE Operanden true sind (1 < 3 && 3 > 1 ist false). 1 < 3 && true ist true). Die ODER-Operation wird als true ausgewertet, wenn MINDESTENS EIN Operand true ist (z. B. 1 < 3 || 3 > 1 ist true, 1 > 3 || 3 > 5 ist false). Die NICHT-Operation kehrt einen booleschen Wert um (!1 > 3 ist true, !true ist false). Die XOR-Operation ergibt wahr, wenn genau einer der Operanden wahr ist (1 < 3 ^ 3 > 1 ist true, 1 > 3 ^ 3 > 5 ist false). Die runden Klammern sind nicht erforderlich, werden jedoch zur Lesbarkeit empfohlen."
"bitwise_operators":::"Jedes Integer-Literal kann durch eine Binärzahl (Nullen und Einsen) dargestellt werden (z. B. 4 wird durch 100 dargestellt). Bitweise Operatoren sind logische Funktionen auf Bitebene. Es gibt ~ für bitweises NICHT und & für bitweise UND, | für bitweises ODER und ^ für bitweises XOR. Durch Interpretation einer 1 mit true und einer 0 mit false können diese Operationen auf int, short, long, char und byte angewendet werden. Beispiel: 3 | 2 ist 3, weil auf der Bitebene gilt: 0b11 | 0b01 == 0b11. \nAußerdem gibt es die Operatoren <<, >> und >>>, die die Bits eines Integerliterals verschieben. a << n verschiebt die Binärdarstellung von a, n-mal nach links (0 wird links hinzugefügt). a >> n verschiebt a n-Mal nach rechts und a >>> n verschiebt a n-nal nach rechts und behält das Vorzeichen von a bei. Wenn beispielsweise a == 4 ist, dann ist a >> 1 == 2 (0b100 -> 0b10); a << 1 == 8 (0b100 -> 0b1000). Beide Operanden (a und n) können nur vom Typ int sein. "
"assignment_operators":::"= ist die einfache Zuweisung. Operatoren für komplexe Zuweisungen führen eine Operation aus und weisen dann den Wert dieser Operation in einem Schritt zu (z.B. entspricht a += 3, a = a + 3). +=, -=, *=, /=, %= sind Zuweisungen nach Summe, Differenz, Produkt, Quotient, Rest. <<=, >>=, >>>= sind Zuweisungen nach bitweiser Linksverschiebung, vorzeichenbehafteter Rechtsverschiebung und vorzeichenloser Rechtsverschiebung . &=, ^= und |= sind Zuweisungen durch bitweises AND, XOR und OR. \nJeder dieser Zuweisungsoperatoren führt zuerst die Operation aus und weist dann den neuen Wert zu."
lesson: statements
"expressions":::"Ein Ausdruck ist ein Konstrukt aus Variablen, Operatoren und Methodenaufrufen. Ein Ausdruck kann immer ausgewertet werden. Beispiel 3 + A [0] wird zu 8 ausgewertet, wenn A [0] den Wert 5 hat . "
"statements":::"Anweisungen sind Ausführungseinheiten. Jede Anweisung muss mit einem Semikolon enden. Du können in drei Gruppen unterteilt werden: Ausdrucksanweisungen, Deklarationsanweisungen und Kontrollflussanweisungen (nächste Lektion). Ausdrucksanweisungen enthalten Zuweisungsausdrücke, ++ und - und Methodenaufruf (in zwei Lektionen). Deklarationsanweisungen enthalten eine beliebige Deklaration einer Variablen (oder eines Arrays). "
"code_blocks":::"Ein Block ist eine Folge von Anweisungen, die in {und} eingeschlossen sind. Ein Codeblock kann leer sein oder 1 oder mehrere Anweisungen enthalten. Ein Codeblock kann auch ... einen Codeblock / Codeblöcke enthalten Codeblöcke dienen zum Zusammenfassen von Anweisungen, die sich logisch auf eine Einheit beziehen, die später ausgeführt wird und verwendet werden kann (dh, Du wirst in Kontrollstrukturen, Methodendefinitionen, Klassen usw. verwendet). "
lesson: controll_structures
"boolean_expression":::"Ein boolescher Ausdruck ist ein Ausdruck, der mit wahr oder falsch bewertet werden kann (z. B .: 2 >> 1! = 7)."
"if":::"Die if-Anweisung führt eine Anweisung oder einen Codeblock aus, wenn ein boolescher Ausdruck wahr ist. \nif (boolescher Ausdruck) {\n// Codeblock \n} \nHier ist ein Beispiel: if (x < 0) {x * = - 1} (Nach diesem Ausdruck ist x immer positiv oder 0. Wenn x positiv oder 0 ist, wird die Anweisung nicht ausgeführt. Wenn x jedoch negativ ist (dh x <0 ist wahr) und Anweisung in geschweiften Klammern wird ausgeführt.). "
"switch":::"Eine switch-Anweisung ist eine Drop-Unterscheidung, dh eine Folge von if-Anweisungen. Die switch-Anweisung führt einen Codeblock aus, wenn eine Variable einen bestimmten Wert hat. Diese auf einem Wert badurende Reaktion wird als case bezeichnet. Die Syntax ist switch (Variable) {case value1: {/* Anweisungen; */ break;}; ... default: /* Anweisungen; */ break;}. Der Standardfall wird ausgelöst, wenn kein anderer Fall vorliegt. Code für jeden case sollte mit dem break-Schlüsselwort enden, aber es ist möglich, es wegzulassen, wodurch die Ausführung zum nächsten Label weitergeht. switch-Anweisungen in Java können als Variablen byte, short, char und int verwenden. "
"while":::"Eine while-Schleife führt einen Codeblock aus, solange ein boolescher Ausdruck wahr ist. \nSyntax: while (boolescher Ausdruck) {\n// Codeblock \n}. oder while (Ausdruck) // Anweisung. \nBeispiel: int i = 0; while (i <10) {++ i; System.out.println (i);} Iteration i von 0 bis 10. "
"do_while":::"In der do-while-Schleife wird der Test nach jeder Iteration durchgeführt. Folglich wird der Code immer mindestens einmal ausgeführt. Die Syntax lautet: do {/* Codeblock */} while (Boolescher Ausdruck ); \nint i = 0; mache {++ i; System.out.println (i);} while (i <10); werde i von 0 bis 10 durchlaufen. "
"for":::"Eine for-Schleife iteriert eine Variable und führt einen Codeblock aus, solange eine Bedingung erfüllt ist. for-Schleifen in Java enthalten einen Initialidurer (z. B. int a = 0;), einen booleschen Ausdruck (z. B. false oder a <10) und ein Zählerausdruck (z.B. ein ++), aber der Initialidurer und der Zählerausdruck können beliebige Anweisungen sein. Die Syntax lautet: for (Anweisung; boolescher_Ausdruck; Anweisung) {/* Codeblock */} \nHier ein Beispiel: für (int i = 0; i <10; i ++) {System.out.println (i);}. \nDie beiden Anweisungen und der boolesche Ausdruck können leer sein: for (;;); ist eine gültige, unendliche for-Schleife . "
"extended_for":::"Die erweiterte for-Schleife durchläuft alle Elemente eines Arrays. Die Syntax lautet: for (variable_definition: array_name) {/* codeblock */} \nZum Beispiel: String [] names = {" anna ", "john", "mary", "bob"}; für (String name: names) System.out.println (name); Ausgabe: "anna", "john", "mary", "bob". "
"break":::"Die Anweisung break; kann verwendet werden, um eine Schleife vorzeitig zu verlassen. Beispiel: for (int i = 0; i <9; i ++) {if (i * i> = 9) break;} will Brechen du die Schleife bei i = 3. "
"continue":::"continue; kann verwendet werden, um zum Anfang der Schleife zu springen und so eine Iteration zu überspringen. Beispiel: for (int i = 0; i <9; i ++) {if (i% 2 == 0) Fortsetzen; überspringt alle Iterationen, bei denen ich gerade bin. ”
lesson: methods
"method_definition":::"Mit einer Methode kannst du einen Codeblock badurend auf Parametern ausführen und eine Variable / ein Array zurückgeben. Die Parameter sollten bestimmen, was im Codeblock pasdurt und was das Ergebnis der Methode ist. Methoden werden in a definiert . Klasse die Syntax für eine gültige Methode Definition lautet: \naccess_modifier Modifikator Rückgabetyp Name (Parameterliste) {/* functionbody mit return-Anweisung */} \ndie Parameterliste ist eine Liste der variablesdefinitions (ohne;), die durch getrennt ist. ",". Diese einfache Methode kann zum Beispiel die Summe zweier int-Variablen zurückgeben: public static int square (int a) {return a * a;}. Square hat die Modifikatoren public und static, die bestimmen, wie auf die Methode zugegriffen wird. square ist der Name der Methode, int ist der Typ, der zurückgegeben wird - der Typ des Ergebnisses. Der Parameter int a bestimmt, mit welchen Arten von Argumenten auf diese Methode zugegriffen werden kann (aufgerufen). (Alles, was zu einem int ausgewertet werden kann (int literal, in) \nEs muss keinen Parameter geben oder einen Rückgabewert. (Du würdest dann nur als Rückgabe stornieren). Die kürzeste Methodendefinition lautet also: void a () {}. Diese Methode wird eigentlich nichts tun. \nvoid a (int a, String b) {} macht dasselbe, muss aber mit einem int und einem String aufgerufen werden. "
"method_modifiers"::: "Methoden können verschiedene Modifikatoren in ihrer Definition haben, die sich ändern, wie auf du zugegriffen wird abstrakt -.. Abstrakte Methoden in abstrakten Klassen nur vorhanden sein können Solche Verfahren haben keinen Körper und muss in einer Unterklasse überschrieben werden, wenn es abstrakt ist . selbst statisch - macht die Methode statisch und damit zugänglich mit der Klasse, ohne Schaffung einer Klasseninstanz jedoch statische Methoden nicht nicht-statische Member in der gleichen Klasse zugreifen eine statische Methode würde wie folgt aufgerufen werden: classname.methodname (parameter~~POS=TRUNC.. ) ;. final erklärt, dass das Verfahren nicht in einer Unterklasse überschrieben wird Zugriffsmodifikatoren die mit Klassen identisch sind:.. öffentlich, geschützt, privat keine Sorge, ich Ihnen erklären, welche Klassen in der nächsten Lektion sind und was Diese Zugriffsmodifikatoren bedeuten. "
"method_access":::"Auf Methoden kann auf verschiedene Arten zugegriffen werden. Auf statische Methoden wird über den Klassennamen zugegriffen: classname.method (parameter) (z.B. Math.min (2,3);). Eine statische Methode, die in a definiert wurde Auf die Klasse kann ohne Klassennamen zugegriffen werden (z.B. min (3,4);). Auf Member-Methoden (nicht statisch) wird über ein Objekt dieser Klasse zugegriffen (egxequals (y);). Methoden können andere Methoden als Argumente verwenden (if der Parameter und der Argumenttyp stimmen überein) (z.B. System.out.println (Math.min (2,3));). "
lesson: classes
"class_definition":::"Klassen bieten wie Methoden eine Möglichkeit, Code kompakter zu schreiben und Code wiederzuverwenden. Klassen können wie folgt definiert werden: Klassenname {// Klassenfelder und Klassenmethoden}. Klassenkonstruktoren können wie folgt definiert werden: public name (parameter) {// Konstruktor}. Eine Klassendefinition kann Variablendefinitionen und Methodendefinitionen enthalten (die als ihre Mitglieder bezeichnet werden). "
"class_modifiers":::"Wie bei Methoden gibt es einige Modifikatoren zum Ändern der Barrierefreiheit. abstract - Gibt an, dass eine Klasse nur als Basisklasse dient und nicht instanziiert werden kann. static - Wird nur für Elementklassen verwendet. Gibt an, dass die Elementklasse verwendet wird gehört nicht zu einer bestimmten Instanz der enthaltenden Klasse. final - Klassen, die als final markiert sind, können nicht erweitert werden und dürfen keine Unterklassen haben. "
"inheritance":::"Eine Klasse kann Methoden und Variablen an untergeordnete Klassen erben. Die Syntax hierfür duht folgendermaßen aus: class child_class extended parent_class {...}. \nBeispiel: \nclass Person {String name;} \nKlassenlehrer erweitert Person {void change_name (String newname) {this.name = newname;}}. Der Klassenlehrer erbt den Variablennamen von Person und kann ihn in change_name verwenden. Kinder können von Kindern erben und so weiter kann eine Vererbungshierarchie aufbauen. "
"access_modifiers":::"Zugriffsmodifikatoren geben an, wo du eine Klassendefinition sehen und daher instanziieren (ein Objekt erstellen). public: von überall; protected: von einer erweiterten Klasse in einem anderen Paket; package (Standard): andere Klassen innerhalb desselben Pakets (dieser Modifikator kann nicht als Schlüsselwort verwendet werden); privat: gleiche Klasse oder verschachtelte Klasse. Wenn beispielsweise eine Klasse A eine private Klasse B enthält, kann nur A B verwenden. "
"object_declaration":::"Wenn eine Klasse definiert wurde, kannst du ein Objekt dieser Klasse deklarieren. Dieses Objekt enthält alle Variablen, die du für die Klasse definiert haben, und kann alle in der Klassendefinition definierten nicht statischen Methoden verwenden. Die Syntax lautet: classname objectname = new classname () ;. "
"class_fields":::"Felder oder Klassenvariablen können innerhalb des Klassenkörpers deklariert werden, um einen Zustand (Variablen) zu beschreiben oder das Verhalten von Objekten (Methoden) zu ändern. Zum Beispiel: class number {int value = 0; \nAuf du kann folgendermaßen zugegriffen werden: objectname.member ;. Wenn das Feld statisch ist, kann über classname: classname.member ;. auf Felder zugegriffen werden von der Klasse, kein Objekt) .finale - Ermöglicht die einmalige Initialisierung des Feldes in einem Konstruktor oder innerhalb des Initialisierungsblocks oder während seiner Deklaration, je nachdem, welcher Zeitpunkt früher liegt. Felder können mit Zugriffsmodifikatoren geändert werden. Ein Objekt kann sein Mitglied erreichen mit dem Schlüsselwort this. Beispiel: this.a ;. "
"member_access_variables":::"Der Operator . ermöglicht den Zugriff auf eine Variable einer Klasse (z. B. player_one.name).
"member_access_methods":::"Der Operator . ermöglicht auch den Zugriff auf eine Member-Methode einer Klasse (z. B. player_one.getName()).