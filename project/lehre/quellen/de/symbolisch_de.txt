lesson: programm_structure
"programm_structure_main":::"Der Einstiegspunkts einer Java-Anwendung ist die sogenannte Main-methode. Jede Java-Anwendung muss eine Main-methode mit folgendem Aufbau haben: public static void main(String a []){}. In geschweiften Klammern kannst du den Code schreiben, den du ausführen möchtest. Es könnte beispielsweise die Anweisung System.out.println("Hello") sein. Zur Erklärung: System.out.println() gibt einen String auf der Konsole aus und"Hello" ist der String, der ausgegeben werden soll."
"programm_structure_import":::"Der Code anderer Java-Dateien kann in deinem Programm verwendet werden. Dies wird durch eine Importdeklaration erreicht. Eine Importdeklaration importiert Code (der sich auf deinem Computer befindet), indem ein Pfad zu den entsprechenden Java-Dateien angegeben wird. Du kannst den Code dann verwenden, indem du einen einfachen Namen statt des vollständigen Pfads zu dem Ordner verwendest, der das Paket enthält. Importdeklarationen müssen nach der Packagedeklaration am Anfang einer Java-Datei geschrieben werden. Das siehst folgendermaßen aus: import identifier[.identifier]*; (Das * bedeutet, dass der Teil in [] wiederholt werden kann). Ein Bezeichner ist vorerst nur ein Name wie"java" oder"math". Hier ein Beispiel: import java.util.Random; (java ist ein Paket, welches util enthält, welches wiederum die Klasse Random enthält).". Du kannst * als Platzhalter hinzufügen, um jeden Pfad zu importieren, der gegen * ausgetauscht werden kann. Zum Beispiel würde"import java.util.*;"  alles importieren, was in util gespeichert ist (einschließlich java.util.Random)."
"programm_structure_packages":::"Ein Packagedeklaration (Paketdeklaration) wird verwendet, um Java-Dateien in ein Paket zu binden, welches importiert werden kann. Eine Packagedeklaraion siehst aus wie eine importdeklaration, mit dem Unterschied, dass es keine Platzhalter gibt und du diese mit"package" beginnst. Ein Package wird ganz am Anfang deklariert, also am Anfang der Java-Datei (z.B. package application.mylibrary;)."
lesson: basics
"comments":::"Ein Kommentar wird vom Compiler nicht übersetzt und ist für die Leser des Quellcodes bestimmt; zum Beispiel zur Erläuterung eines Codebereichs (was dieser tut, warum usw.). \nEs gibt drei Arten von Kommentaren: \n- Einzeilige Kommentare: Sie beginnen an einem beliebigen Punkt einer Zeile und markieren den Rest der Zeile als Kommentar. Sie werden mit einem // (z. B. // Hallo) eingeleitet \n-Mehrzeilenkommentare: Sie können an jeder beliebigen Stelle in einer Zeile beginnen und so viele Zeilen umfassen, wie du möchtest. Du beginnst mit einem /* und endest mit einem */. \n- Java-Doc: Sie werden wie mehrzeilige Kommentare erstellt und stehen über einer Klasse oder Methode, um diese zu erklären. \nKommentare können andere Kommentare enthalten, aber jeder Kommentar muss korrekt beginnen und abgeschlossen sein. Daher ist /* \n// \n*/ legal, während /*//*/ ist nicht legal ist (weil das */ nicht erkannt wird)."
"literals":::"Ein Literal ist die Quellcodedarstellung eines Werts eines primitiven Typs oder des Nulltyps (leerer Wert). Literale können also Zahlen (4 oder 4.2), Zeichen ('a') oder Zeichenfolgen  ("Hallo"), boolesche Werte (wahr und falsch) oder der leere Wert null sein."
"integer_literals":::"Integer-Literale sind Ganzzahlen (z.B.: -143). Du kannst sie in vier Basen schreiben: \n1. binär: 0b gefolgt von einer Binärzahl (die Ziffern 0 und 1). z.B.: 0b11 \n2 oktal: 0, gefolgt von einer Oktalzahl (Ziffern von 0 bis 7), z.B.: 01245 \n3. hexadezimal 0x, gefolgt von einer hexadezimalen Zahl (Ziffern von 0 bis 9 und Buchstaben A bist F), z.B.: 0xA31F \n4. dezimal (Ziffern von 0 bis 9)."
"floating-point_literals":::"Gleitkommazahlen-Literale stellen Bruchzahlen dar (z.B.: 1.43). Es gibt zwei Typen: float und double. float-Literale werden mit einem Dezimalbruch (z.B. 1.2), gefolgt einem optionalen Exponenten-Indikator geschrieben, gefolgt von F (z.B. 15.3E4F = 153000.0). double-Literale können ein optionales D anstelle eines F (z.B. 2.21E3D = 2210.0) enthalten. Der erste Teil von Gleitkommazahlen-Literalen (vor dem.) und der zweite Teil (nicht beide) sind optional und als Standart eine 0 angenommen wird (z.B. 1F = 0.F, 1D = 1.0).
"character_literals":::"Characterliterale (Zeichenliterale) sind alle ASCII-Zeichen und werden mit ' umhüllt (z.B.:'a'oder '$'). Characterliterale können dem Typ char zugeordnet werden (z.B. char a = 'a'). Es gibt Sonderzeichen, welche keine sichtbaren Zeichen sind, aber eine Funktion haben (z.B. '\\n' ist ein Zeilenumbruch): \'(einfaches Anführungszeichen), \"(doppeltes Anführungszeichen), \\ (umgekehrter Schrägstrich), \t (Tabulator) ), \b (Rücktaste), \r (Wagenrücklauf), \f (Formfeed)."
"string_literals":::"String-Literale sind Strings, sie bestehen also aus einer Folge von Zeichen (z.B. Stringtest ="Hallo"). Strings können mit + verkettet werden (z.B."zwei" +"Wörter" entspricht dem String"zwei Wörter")."
"boolean_literals":::"Boolesche Literale sollen die Gültigkeit einer Aussage widerspiegeln, welche wahr oder falsch sein kann. Es gibt also die booleschen Literale true(wahr) und false(falsch). Vergleiche basieren auf einem booleschen Wert (z.B. 3 < 9 ist true, 3 > 9 ist false).
"null_literal":::"Das Literal null kennzeichnet die Abwesenheit eines Wertes (es ist eine leere Speicherreferenz). Es kann einer Variablen eines beliebigen Typs (z. B. int a = null;) zugewiesen werden, um diesen zu markieren. Wenn eine Variable mit einer Nullreferenz gelesen werden soll, wird eine NullPointerException (ein Fehler) erzeugt. null wird verwendet um zu prüfen, ob eine Variable bereits initialisiert wurde (dies wird mit var == null getan)."
"keywords":::"Ein Schlüsselwort ist eine reservierte Zeichenfolge mit einer Semantik die in der Sprache definiert wurde. Bei Schlüsselwörtern wird zwischen Groß- und Kleinschreibung unterschieden. Zu den Schlüsselwörtern gehören: abstract, continue, for, new, switch, assert, default, if, package, synchronized, boolean, do, goto, private, this, break, double, implements, protected, throw, byte, else, import, public, throws, case, enum, instanceof, return, transient, catch, extends, int, short, try, char, final, interface, static, void, class, finally, long, strictfp, volatile, const, float, native, super and while."
"identifiers":::"Ein Bezeichner ist ein Name, der auf etwas im Code verweist (eine Variable, eine Methode, eine Klasse ...). Bei Bezeichnern in Java wird die Groß- und Kleinschreibung beachtet. Ein Bezeichner kann Folgendes enthalten: \nJedes Unicode-Zeichen welches ein Buchstabe ist (einschließlich numerischer Buchstaben wie römische Ziffern) oder Ziffern. \n- Das Währungszeichen (wie z. B. $). \n- Der Unterstrich (wie z. B. _). \nAber ein Bezeichner kann nicht: \n1. Mit einer Ziffer beginnen oder \n2. Einem reservierten Schlüsselwort, null, true oder false entsprechen \n3. Es dürfen nicht zwei identische Bezeichner für verschiedene Strukturen benutzt werden."
"types":::"Daten werden in verschiedenen Formen gespeichert, die als Typen bezeichnet werden. Die Daten, die einem bestimmten Typ entsprechen, können etwas in der Realität oder einer Idee darstellen. Beispielsweise können 3 Strings (Name, Nachname und Adresse) eine Identifikation für eine Person sein oder 3 Ganzzahlen können eine Farbe im RGB-Format darstellen. Was ich gerade beschrieben habe, sind benutzerdefinierte Typen. Es gibt jedoch auch eingebaute Typen (die als Bausteine ​​für benutzerdefinierte Typen verwendet werden können. Die eingebauten Typen werden als primitive Typen bezeichnet. Es gibt Typen für Integer (ganze Zahlen): char, int, long, short und byte, die sich im Bereich der von ihnen darstellbaren Zahlen unterscheiden. Gleitkommazahlen: float und double. double kann einen breiteren Bereich von Zahlen darstellen. Der Typ char kann auch Zeichen darstellen und der Typ String stellt Strings (Zeichenfolgen) dar. Der Typ boolean stellt die Werte true und false dar. \nHier sind die Bereiche für die verschiedenen Ganzzahlentypen: \n• Für Byte, von - 128 bis 127 \n• short, von -32768 bis 32767 \nFür int, von -2147483648 bis 2147483647 \nlong, von -9223372036854775808 bis 9223372036854775807 \n• Für char, von '\ u0000' bis '\ uffff' einschließlich, dh von 0 bis 65535."
"variable_definition":::"Variablen können zum Speichern von Daten bzw. Werten verwendet werden (z.B. von Literalen). Variablen haben einen Namen, einen Typ und einen Wert, der diesem Typ zugeordnet ist. So kann beispielsweise eine int Variable ein Integerliteral speichern. Sie werden durch schreiben des Variablentyps, dann des Variablennamens und zuletzt eines Semikolons definiert. Beispiel: int var;"
"variable_definition_initialization":::"Eine Variable kann in derselben Anweisung definiert und initialisiert werden, indem ein Wert zugewiesen wird, der dem Typ entspricht (z.B.: int a = 9;)."
"variable_access":::"Auf eine zuvor definierte Variable kann mit deinem Bezeichner zugegriffen werden. \n Hier ist ein Beispiel: Definition einer Variablen (int a;) und anschließender Zugriff (Ausgabe mit System.out.println();: System.out.println(a);)."
"variable_reassignment":::"Eine Variable kann neu zugewiesen werden, indem ein passendes Literal, eine Variable, die Rückgabe einer Methode oder ein Array-Element desselben Typs zugewiesen wird."
lesson: arrays
"array_definition":::"Arrays enthalten eine Folge von Variablen desselben Typs. Sie haben immer eine feste Größe. So kann ein Integer-Array der Größe 3, 3 Integer speichern. Arrays werden wie folgt definiert: typ name[]; oder so: typ[] name;. Es gibt absolut keinen Unterschied zwischen diesen beiden Varianten. Bevor sie verwendet werden können, müssen sie deklariert werden (die Anzahl der Elemente muss festgelegt werden). Ein Element eines Arrays kann wie eine"normale" Variable desselben Typs verwendet werden."
"array_declaration":::"Eine Array-Deklaration beschreibt, wie viele Elemente ein Array enthält, und initialisiert sie mit einem Standardwert (0 für Zahlen, der leere String für Strings, das leere Zeichen für char, true für Booleans oder null für andere Typen). Erst nach der Array-Definition und Array-Deklaration kannst du das Array verwenden. Du kannst zuerst ein Array definieren und es dann wie folgt deklarieren: typ Arrayname[];  und dann deklarieren: Arrayname = new Typ[Elemente]; (z.B. int []a; a = new int [3];). \nDu können dies aber auch in einem Schritt tun: Typ[] name = new Typ[größe]; (z.B. int y[] = new int[2]; - ​​dies erzeugt das Array y mit 2 Elementen) (Hinweis: Die Indizes beginnen bei 0. Das heißt, y hat zwei Elemente: y[0] und y[1])."
"array_definition_initialization":::"Arrays können mit benutzerdefinierten Werten in einem Schritt wie folgt definiert, deklariert und initialisiert werden: typ name[] = {value1, ..., valueN} (z.B. int a[] = {1,2,3};). Diese Initialisierung kann nur einmal zusammen mit der Definition durchgeführt werden."
"array_access":::"Auf Arrays wird folgendermaßen zugegriffen: name[index] (z.B. y[0]). Zugriff heißt, das der in diesem Element gespeicherte Wert zurückgegeben wird."
"array_reassignment":::"Ein einzelnes Element eines Arrays kann folgendermaßen ein neuer Wert zugewiesen werden: name[index] = wert; (z.B. name[3] ="hans";)."
"multidim_array_definition":::"Ein multidimensionales Array ist ein Array, das ein Array oder Arrays von Arrays oder Arrays von Arrays von Arrays enthält u.s.w.. Ein zweidimensionales Array besteht beispielsweise aus einem Array von Arrays. Das bedeutet, dass die Arrayelemente in der ersten Dimension ein eindimensionales Array haben. In Java werden mehrdimensionale Arrays wie folgt definiert: Typ name[]...[]; oder Typ[]...[]name; (z.B. int [][]a; für ein zweidimensionales Array). Hier ein Beispiel: Ein Array mit der Größe 1920 * 1080 hat 1920 Elemente in der ersten Dimension. Jedes Element der ersten Dimension hat ein Array mit 1080 Elementen. Ein Array wie dieses könnte verwendet werdem um ein Full-HD-Bild zu beschreiben - jedes Element dieses Arrays würde einen Pixel darstellen."
"multidim_array_declaration":::"Das multidimensionale Array kann folgendermaßen deklariert werden: Typ []...[] name = new Typ[dimension1] ... [dimensionN]; (z.B. int [][]numbers = new int[3][3]; - dies erzeugt das Array y mit 3 * 3 int's."
"multidim_array_access":::"Auf multidimensionale Arrays wird folgendermaßen zugegriffen: name[index1] ... [indexN] (z.B. int a[][] = new int[2][2]; a [0][1] ist 0.)
"multidim_array_reassignment":::"Das ist die Syntax für die Neuzuweisung von Elementen: name[Index1]...[IndexN] = Wert; (z.B. a[0][0] = 1;)."
lesson: operators
"arithmetic_operators":::"Arithmetische Operatoren können Integerliterale und Gleitkommazahlenliterale verbinden, + kann zusätzlich zur Verkettung von Strings verwendet werden. + entspricht der Addition von Zahlen, - entspricht der Subtraktion, * entspricht der Multiplikation, / entspricht der Division, % entspricht der Modulooperation. Modulo ist der Rest aus einer ganzzahligen Division (z.B. 2 % 4 ist gleich 2, weil 2/4 = 0 ist als Ganzzahldivision, mit einem Rest von 2 (2 = 4 * 0 + 2). Ein zweites Beispiel: 5 % 4 ist 1, weil 5/4 = 1, Rest 1 ist (5 = 1 * 4 + 1)."
"operators_prefix":::"Inkrementieren bedeutet in Java, 1 auf eine Ganzzahl zu addieren, dekrementiert bedeutet 1 von einer Ganzzahl zu subtrahieren. Um eine Variable von Ganzzahltypen (int, long, short, byte oder char) zu inkrementieren, nutzen wir den Inkrementierungsoperator ++ und um eine Variable zu dekrementieren, kann der Dekrementierungsoperator -- verwendet werden (z.B. ++a ist gleich a + 1, --a ist gleich a - 1). Wenn ein Inkrementierungs- oder Dekrementierungsoperator vor einer Variablen steht, wird der Wert erst inkrementiert oder dekrementiert und dann der Variablen zugewiesen (z.B. ++a oder --a). Wenn ++ oder -- vor eine Variable geschrieben werden, werden sie Präfixoperatoren genannt."
"operators_postfix":::"Der Inkrementierungs- oder Dekrementierungsoperator kann hinter eine Variable geschrieben werden (z.B. a++). Wenn sie nach einer Variablen geschrieben werden, wird die Variable zuerst zugewiesen und dann inkrementiert. Beispiel: Wenn die int-Variable a 3 ist, System.out.println(a++); wird 3 ausgegeben, weil a zugewiesen und dann inkrementiert wird. Das bedeutet, dass ein zusätzliches System.out.println(a); 4  ausgeben würde. Wenn ++ oder -- nach einer Variablen geschrieben werden, werden sie als Postfix-Operatoren bezeichnet."
"comparison_operators":::"Vergleichsoperatoren können zum vergleichen von Zahlen verwendet werden. Kleiner als: <, größer als: >, kleiner-gleich: <=, größer-gleich: >=, ungleich: != und gleich: ==, werden verwendet um Zahlen zu vergleichen und ein boolesches Literal zurückzugeben. == und != können auch jeden anderen Typ oder Null vergleichen, solange beide Operanden vom gleichen Typ sind. \nEs ist wichtig zu verstehen, dass in java = kein Vergleich ist, sondern eine Zuweisung. == ist der Gleichheitsoperator in Java."
"logic_operators":::"Logikoperatoren können Operanden mit den booleschen Werten"true" oder"false" kombinieren. Als Operanden sind nicht nur die Literale true und false zulässig, sondern auch Variablen vom Typ boolean, boolesche Ausdrücke, Methoden, die true oder false zurückgeben oder  Vergleichsoperationen. Java kennt folgende logische Operationen. Die UND-Operation wird nur dann zu true ausgewertet, wenn BEIDE Operanden true (wahr) sind (1 < 3 && 3 > 1 ist false). 1 < 3 && true ist true). Die ODER-Operation wird als true ausgewertet, wenn MINDESTENS EIN Operand true ist (z.B. 1 < 3 || 3 > 1 ist true, 1 > 3 || 3 > 5 ist false). Die NICHT-Operation kehrt einen booleschen Wert um (!(1 > 3) ist true, !true ist false). Die XOR-Operation ergibt wahr, wenn genau einer der Operanden wahr ist (1 < 3 ^ 3 > 1 ist true, 1 > 3 ^ 3 > 5 ist false). ! ist das logische NICHT (z.B.! (3 < 9) ergibt false), && ist das logische UND (z.B. (!true) && true ergibt false), || ist das logische OR (z.B. true || false wird zu true ausgewertet, true || true ist true) und ^ ist das logische XOR (true ^ false ist true). Die runden Klammern sind nicht erforderlich, werden jedoch zur Lesbarkeit empfohlen."
"bitwise_operators":::"Jedes Integer-Literal kann durch eine Binärzahl (Nullen und Einsen) dargestellt werden (z.B. 4 wird durch 100 dargestellt). Bitweise Operatoren sind logische Funktionen auf Bitebene. Es gibt ~ für bitweises NICHT und & für bitweise UND, | für bitweises ODER und ^ für bitweises XOR. Durch Interpretation einer 1 mit true und einer 0 mit false können diese Operationen auf int, short, long, char und byte angewendet werden. Beispiel: 3 | 2 ist 3, weil auf der Bitebene gilt: 0b11 | 0b01 == 0b11. \nAußerdem gibt es die Operatoren <<, >> und >>>, die die Bits eines Integerliterals verschieben. a << n verschiebt die Binärdarstellung von a, n-mal nach links (0 wird links hinzugefügt). a >> n verschiebt a n-Mal nach rechts und a >>> n verschiebt a n-nal nach rechts und behält das Vorzeichen von a bei. Wenn beispielsweise a == 4 ist, dann ist a >> 1 == 2 (0b100 -> 0b10); a << 1 == 8 (0b100 -> 0b1000). Beide Operanden (a und n) können nur vom Typ int sein."
"assignment_operators":::"= ist die einfache Zuweisung in Java. Operatoren für komplexe Zuweisungen führen eine Operation aus und weisen dann den Wert dieser Operation in einem Schritt ein Variable zu (z.B. entspricht a += 3, a = a + 3). +=, -=, *=, /=, %= sind Zuweisungen nach Summe, Differenz, Produkt, Quotient, Rest. <<=, >>=, >>>= sind Zuweisungen nach bitweiser Linksverschiebung, vorzeichenbehafteter Rechtsverschiebung und vorzeichenloser Rechtsverschiebung . &=, ^= und |= sind Zuweisungen durch bitweises AND, XOR und OR. \nJeder dieser Zuweisungsoperatoren führt zuerst die Operation aus und weist dann den neuen Wert zu."
lesson: statements
"expressions":::"Java kennt viele Formen von Ausdrücken. Ein Ausdruck kann aus Variablenzugriffen, Arrayzugriffen, Operatoren und Methodenaufrufen bestehen. Jeder Ausdruck kann ausgewertet werden. Beispiel: 3 + A[0] wird zu 8 ausgewertet, wenn A[0] den Wert 5 hat."
"statements":::"Anweisungen sind Ausführungseinheiten. Jede Anweisung muss mit einem Semikolon enden. Sie können in drei Gruppen unterteilt werden: Ausdrucksanweisungen, Deklarationsanweisungen und Kontrollflussanweisungen (nächste Lektion). Ausdrucksanweisungen können Zuweisungsausdrücke, ++ und - und Methodenaufrufe (in zwei Lektionen) enthalten. Deklarationsanweisungen enthalten eine beliebige Deklaration einer Variablen (oder eines Arrays)."
"code_blocks":::"Ein Block ist eine Folge von Anweisungen, die in { und } eingeschlossen sind. Ein Codeblock kann leer sein oder eine oder mehrere Anweisungen enthalten. Ein Codeblock kann auch einen Codeblock bzw. mehrere Codeblöcke enthalten. Codeblöcke dienen zum Zusammenfassen von Anweisungen zu einer Einheit, welche später ausgeführt und verwendet werden kann."
lesson: controll_structures
"boolean_expression":::"Ein boolescher Ausdruck ist ein Ausdruck, der zu einem booleschen Wert, also true(wahr) oder false(falsch) ausgewertet werden kann (z.B .: 2 >> 1 != 7)."
"if":::"Die if-Anweisung führt eine Anweisung oder einen Codeblock aus, wenn ein boolescher Ausdruck wahr ist. \n Die Syntax ist: if(boolescher Ausdruck){\n// Codeblock \n} oder if(boolescher Ausdruck)//Anweisung; \nHier ist ein Beispiel: if(x < 0){x * = - 1;} (Nach diesem Ausdruck ist x immer positiv oder 0. Wenn x positiv oder 0 ist, wird die Anweisung nicht ausgeführt. Wenn x jedoch negativ ist (dh x <0 ist wahr) und Anweisung in geschweiften Klammern wird ausgeführt.)."
"switch":::"Eine switch-Anweisung ist eine Fallunterscheidung, d.h. eine Folge von if-Anweisungen. Die switch-Anweisung führt einen Codeblock aus, wenn eine Variable einen bestimmten Wert hat. Diese auf einem Wert beruhende Reaktion wird als case (Fall) bezeichnet. Die Syntax ist switch (Variable) {case wert1: {/* Anweisungen; */ break;}; \n ... \n default: /* Anweisungen; */ break;}. Der Standardfall (default) wird ausgelöst, wenn kein anderer Fall vorliegt und ist optional. Code für jeden case sollte mit dem break-Schlüsselwort enden, aber es ist möglich, es wegzulassen, wodurch die Ausführung zum nächsten Label weitergeht. switch-Anweisungen in Java können mit Variablen mit Typ byte, short, char und int verwenden."
"while":::"Eine while-Schleife führt einen Codeblock aus, solange ein boolescher Ausdruck wahr ist. \nSyntax: while(boolescher Ausdruck) {\n/*Codeblock*/\n}. oder while(Ausdruck)//Anweisung;. \nBeispiel: int i = 0; while(i <10) {++ i; System.out.println (i);} Iteration i von 0 bis 10."
"do_while":::"In der do-while-Schleife wird der Test nach jeder Iteration durchgeführt. Folglich wird der Code immer mindestens einmal ausgeführt. Die Syntax lautet: do {/* Codeblock */} while (Boolescher Ausdruck ); \n Beispiel: int i = 0; do{++ i; System.out.println (i);} while (i <10); wird i von 0 bis 10 durchlaufen."
"for":::"Eine for-Schleife iteriert eine Variable und führt einen Codeblock aus, solange eine Bedingung erfüllt ist. for-Schleifen in Java enthalten einen Initialisierer (z.B. int a = 0;), einen booleschen Ausdruck (z.B. false oder a <10) und ein Iterationsausdruck (z.B. a++), aber der Initialisierungsausdruck und der Zählerausdruck können beliebige Anweisungen sein. Die Syntax lautet: for(Initialisierungsanweisung; boolescher_Ausdruck; Iterationsanweisung) {/* Codeblock */} oder for(Initialisierungsanweisung; boolescher_Ausdruck; Iterationsanweisung)//Anweisung; \nHier ein Beispiel: for(int i = 0; i <10; i ++) {System.out.println (i);}. \nDie beiden Anweisungen und der boolesche Ausdruck können leer sein: also for (;;); ist eine gültige, unendliche for-Schleife ."
"extended_for":::"Die erweiterte for-Schleife durchläuft alle Elemente eines Arrays. Die Syntax lautet: for (variablendefinition: array_name) {/* codeblock */} \nZum Beispiel: String[] names = {" anna","john","mary","bob"}; for(String name: names) System.out.println(name);. Die Ausgabe ist:"anna","john","mary","bob"."
"break":::"Die Anweisung break; kann verwendet werden, um eine Schleife vorzeitig zu verlassen. Beispiel: for(int i = 0; i <9; i ++){if(i * i> = 9)break;} wird die Schleife bei i = 3 abbrechen."
"continue":::"continue; kann verwendet werden, um einen Schleifendurchlauf und damit zum Anfang der Schleife zu springen. Beispiel: for(int i = 0; i <9; i ++){if(i% 2 == 0)continue; überspringt alle Iterationen, bei denen i gerade ist.”
lesson: methods
"method_definition":::"Mit einer Methode kannst du einen Codeblock abhängig von Parametern ausführen und eine Variable bzw. ein Array zurückgeben. Die Parameter sollten bestimmen, was im Codeblock passiert und was das Ergebnis der Methode ist. Methoden müssen erst definiert werden, bevor sie verwendet werden können. Die Syntax für eine gültige Methodendefinition lautet: zugangsmodifikator staticmodifikator Rückgabetyp Name(Parameterliste) {/*Codeblock mit return-Anweisung */} \ndie Parameterliste ist eine Liste von Variablendefinitionen (ohne Semikolon), die durch Kommata getrennt ist. Diese einfache Methode kann zum Beispiel die Summe zweier int-Variablen zurückgeben: public static int square(int a){return a * a;}. square hat die Modifikatoren public und static, die bestimmen, wie auf die Methode zugegriffen wird. square ist der Name der Methode, int ist der Typ, der zurückgegeben wird - der Typ des Ergebnisses. Der Parameter int a bestimmt, mit welchen Arten von Argumenten auf diese Methode zugegriffen werden kann (aufgerufen). (Alles, was zu einem int ausgewertet werden kann) \n Im allgemeinen muss es keine Parameter geben und auch keine Rückgabe (dann wird als Rückgabetyp einfach void geschrieben). Die kürzeste Methodendefinition lautet also: void a(){}. Diese Methode wird nichts tun. \nvoid a (int a, String b) {} macht dasselbe, muss aber mit einem int und einem String aufgerufen werden."
"method_modifiers":::"Methoden können verschiedene Modifikatoren in ihrer Definition haben, die ändern, wie auf die Methode zugegriffen wird. abstract: Abstrakte Methoden können nur in abstrakten Klassen vorhanden sein. Solche Methoden haben keinen Methodenkörper(das was zwischen { und }steht) und müssen in einer Kindklasse überschrieben werden, wenn sie abstrakt sind. static: macht die Methode statisch und damit nur zugänglich mit einer Klasse, ohne Erstellung einer Klasseninstanz (Objekt). Jedoch können statische Methoden nicht auf nicht-statische Mitglieder in der gleichen Klasse zugreifen. Eine statische Methode würde wie folgt aufgerufen werden: classname.methodname(parameterliste);. final: zeigt an, dass die Methode nicht in einer Unterklasse überschrieben wird, Zusätzlich gibt es noch Zugriffsmodifikatoren die mit Klassen identisch sind:.. public, protected, privat. Keine Sorge, ich werde später Klassen erklären und damit auch was diese Zugriffsmodifikatoren bedeuten."
"method_access":::"Auf Methoden kann auf verschiedene Arten zugegriffen werden. Auf statische Methoden wird über den Klassennamen zugegriffen: klassenname.methodenname(parameterliste); (z.B. Math.min(2,3);). Auf eine statische Methode, die in einer Klasse definiert wurde, kann in der selben auch ohne Klassennamen zugegriffen werden (z.B. min(3,4);). Auf Member-Methoden (also alle Methoden die nicht statisch sind) wird über ein Objekt dieser Klasse zugegriffen (z.B. equals(y);). Methoden können andere Methoden als Argumente verwenden."
lesson: classes
"class_definition":::"Klassen bieten wie Methoden eine Möglichkeit, Code kompakter zu schreiben und Code wiederzuverwenden. Klassen können wie folgt definiert werden: Zugangsmodifikator Klassenmodifikator Klassenname{// Klassenvariablen und Klassenmethoden}. Mit Klassenkontruktoren kann bestimmt werden,was vor der Objektdeklaration geschehen soll. Klassenkonstruktoren können wie folgt definiert werden: public Klassenname (parameter) {// Konstruktor}. Eine Klassendefinition kann Variablendefinitionen und Methodendefinitionen enthalten (die als ihre member bezeichnet werden)."
"class_modifiers":::"Wie bei Methoden gibt es für Klassen einige Modifikatoren zum ändern von Zugangs- bzw. Verwendungsbeschränkungen. abstract - gibt an, dass eine Klasse nur als Basisklasse für eine Vererbung dient und nicht instanziiert werden kann. static - Wird nur für abstrakte Klassen verwendet. static gibt an, dass eine Mitgliedsklasse nicht einer bestimmten Instanz einer Klasse gehört. final - Klassen, die als final markiert sind, können nicht erweitert werden und dürfen keine Unterklassen haben."
"inheritance":::"Eine Klasse kann Methoden und Variablen an untergeordnete Klassen vererben. Die Syntax hierfür sieht folgendermaßen aus: class Kindklasse extended Elternklasse{...}. \nBeispiel: \nclass Person{String name;} \nclass Lehrer extends Person{void change_name(String newname) {this.name = newname;}}. Die Klasse Lehrer erbt den Variablennamen von Person und kann diesen in change_name verändern. \nHinweis: Kinder können von Kindern erben und so kann eine Vererbungshierarchie aufgebaut werden."
"access_modifiers":::"Zugriffsmodifikatoren geben an, von wo aus eine Klassendefinition zu "sehen" ist und daher instanziiert werden kann (ein Objekt erstellen). public: von überall; protected: von einer erweiterten Klasse in einem anderen Paket; package (Standard): andere Klassen innerhalb desselben Pakets (dieser Modifikator kann nicht als Schlüsselwort verwendet werden); privat: gleiche Klasse oder verschachtelte Klasse. Wenn beispielsweise eine Klasse A eine private Klasse B enthält, kann nur A B verwenden."
"object_declaration":::"Erst wenn eine Klasse definiert wurde, kannst du ein Objekt dieser Klasse deklarieren. Dieses Objekt enthält alle Variablen, die du für die Klasse definiert wurden, und kann alle in der Klassendefinition definierten, nicht statischen Methoden verwenden. Die Syntax lautet: Klassenname Objektname = new Klassenname();."
"class_fields":::"Felder oder Klassenvariablen können innerhalb des Klassenkörpers deklariert werden, um einen Zustand (Variablen) zu beschreiben oder das Verhalten von Objekten (Methoden) zu ändern. Zum Beispiel: class number{int value = 0;} \n Auf Variable number kann folgendermaßen zugegriffen werden: objectname.member;. Wenn das Feld statisch ist, kann über die Klasse: Klassenname.Variablenname; zugegriffen werden)."
"member_access_variables":::"Der Operator . ermöglicht den Zugriff auf eine Variable einer Klasse (z. B. player_one.name).
"member_access_methods":::"Der Operator . ermöglicht auch den Zugriff auf eine Member-Methode einer Klasse (z. B. player_one.getName()).