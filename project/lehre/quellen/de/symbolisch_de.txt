lesson: programm_structure
"programm_structure_main":::"Der Einstiegspunkts einer Java-Anwendung ist die sogenannte Hauptmethode. Jede Java-Anwendung muss eine Hauptmethode mit folgendem Aufbau haben: public static void main(String a []){}. In geschweiften Klammern kannst du den Code schreiben, den du ausführen möchtest. Es könnte beispielsweise ein System.out.println("Hello") sein. System.out.println() gibt einen String auf der Konsole aus und "Hello" ist das, was du ausgeben möchten."
"programm_structure_import":::"Der Code anderer Java-Dateien kann in deinem Programm verwendet werden. Dies wird durch eine Importdeklaration erreicht. Eine Importdeklaration importiert Code (der sich auf deinem Computer befindet), indem ein Pfad zu den entsprechenden Java-Dateien angegeben wird. Du kannst den Code dann verwenden, indem du einen einfachen Namen statt des vollständigen Pfads zu dem Ordner verwendest, der das Paket enthält. Importdeklarationen müssen nach der Packagedeklaration am Anfang einer Java-Datei geschrieben werden. Das siehst folgendermaßen aus: import identifier[.identifier]*; (Das * bedeutet, dass der Teil in [] wiederholt werden kann). Ein Bezeichner ist vorerst nur ein Name wie "java" oder "math". Hier ein Beispiel: import java.util.Random; (java ist ein Paket, welches util enthält, welches wiederum die Klasse Random enthält).". Du kannst * als Platzhalter hinzufügen, um jeden Pfad zu importieren, der gegen * ausgetauscht werden kann. Zum Beispiel würde "import java.util.*;"  alles importieren, was in util gespeichert ist (einschließlich java.util.Random)."
"programm_structure_packages":::"Ein Packagedeklaration (Paketdeklaration) wird verwendet, um Java-Dateien in ein Paket zu binden, welches importiert werden kann. Eine Packagedeklaraion siehst aus wie eine importdeklaration, mit dem Unterschied, dass es keine Platzhalter gibt und du diese mit "package" beginnst. Ein Package wird ganz am Anfang deklariert, also am Anfang der Java-Datei (z.B. package application.mylibrary;)."
lesson: basics
"comments":::"Ein Kommentar wird vom Compiler nicht übersetzt und ist für die Leser des Quellcodes bestimmt, zum Beispiel zur Erläuterung eines Codebereichs (was er tut, warum usw.). \ n Dort Es gibt drei Arten von Kommentaren: \ n- Einzeilige Kommentare: Beginnen du an einem beliebigen Punkt einer Zeile und markieren du den Rest der Zeile als Kommentar. Du wirst mit einem // (z. B. // Hallo) eingeleitet -Zeilenkommentare: können an jeder beliebigen Stelle in einer Zeile beginnen und so viele Zeilen umfassen, wie du möchten. Du beginnst mit einem / * und enden mit einem * /. \ n- Java-Doc: Du wirst wie mehrzeilige Kommentare erstellt und stehen über einer Klasse oder Methode, um du zu erklären. \ nKommentare können andere Kommentare enthalten, aber jeder Kommentar muss korrekt beginnen und abgeschlossen sein. Daher ist / * \ n // \ n * / legal, während / * // * / ist nicht (weil das * / nicht erkannt wird). "
"literals":::"Ein Literal ist die Quellcodedarstellung eines Werts eines primitiven Typs oder des Nulltyps (leerer Wert). Literale können also Zahlen (4 oder 4.2), Zeichen ('a') oder Zeichenfolgen sein ("Hallo"), boolesche Werte (wahr und falsch) oder der leere Wert null. "
"integer_literals":::"Integer-Literale sind Ganzzahlen (zB: -143). Du können in vier Basen geschrieben werden: \ n1. binary: 0b gefolgt von einer Binärzahl (die Ziffern 0 und 1). zB: 0b11 \ n2 oktal: 0, gefolgt von einer Oktalzahl (Ziffern von 0 bis 7), zB: 01245 \ n 3. hexadezimal 0x, gefolgt von einer hexadezimalen Zahl (Ziffern von 0 bis 9 und Buchstaben AF), zB: 0xA31F \ n4. dezimal ( Ziffern von 0-9). "
"floating-point_literals":::"Gleitkomma-Literale stellen Bruchzahlen dar (zB: 1.43). Es gibt zwei Typen: float und double. Gleitkomma-Literale werden mit einem Dezimalbruch mit einem optionalen Exponenten-Indikator geschrieben, gefolgt von F (zB 15.3E4F = 153000.0). Doppel-Literale können ein optionales D anstelle eines F (zB 2.21E3D = 2210.0) enthalten. Der erste Teil (vor dem.) Oder der zweite Teil (nicht beide) sind optional und wenn nicht definiert, wobei angenommen wird, dass es eine 0 ist (z. B. 1F = 0,1F, 1D = 1,0).
"character_literals":::"Zeichenliterale sind alle ASCII-Zeichen und werden mit '(zB:' a 'oder' $ ') umbrochen. Zeichenliterale können dem Typ char zugeordnet werden (zB char a =' a '). Es gibt Sonderzeichen, die keine sichtbaren Zeichen sind, aber eine Funktion haben (z. B. '\\ n' ist ein Zeilenumbruch): \ '(einfaches Anführungszeichen), \ "(doppeltes Anführungszeichen), \\ (umgekehrter Schrägstrich), \ t (Tabulator) ), \ b (Rücktaste), \ r (Wagenrücklauf), \ f (Formfeed). "
"string_literals":::"String-Literale sind Strings, du bestehen also aus einer Folge von Zeichen (zB String-Test =" Hallo "). Strings können mit + verkettet werden (zB (" zwei "+" Wörter "entsprechen" zwei Wörter"))."
"boolean_literals":::"Boolesche Literale sollen die Gültigkeit einer Aussage widerspiegeln, die gleich wahr oder falsch sein kann. Es gibt also die booleschen Literale wahr und falsch. Vergleiche baduren auf einem booleschen Wert (z. B. 3 <9) gleich wahr, 3> 9 gleich falsch).
"null_literal":::"Das Literal null kennzeichnet das Fehlen eines Wertes (es ist eine leere Speicherreferenz). Es kann einer Variablen eines beliebigen Typs (z. B. int a = null;) zugewiesen werden, um du zu markieren. Wenn eine Variable Soll mit einer Nullreferenz gelesen werden, wird eine NullPointerException (ein Fehler) erzeugt, mit der überprüft wird, ob Eine Variable wird bereits mit einem Ausdruck wie var == null initialidurt (var ist eine Variable und == der Gleichheitsoperator in Java). "
"keywords":::"Ein Schlüsselwort ist eine reservierte Zeichenfolge mit sprachdefinierter Semantik. Bei Schlüsselwörtern wird zwischen Groß- und Kleinschreibung unterschieden. Zu den Schlüsselwörtern gehören: abstract, continue, for, new, switch, assert, default, if, package, synchronized, boolean tun, goto, privat, dies, brechen, doppelt, implementiert, geschützt, werfen, byte, sonst, importieren, öffentlich, wirft, fall, enum, instanceof, zurück, trandunt, fangen, erweitert, int, kurz, versuchen, char , final, interface, static, void, class, endlich, long, strictfp, volatile, const, float, native, super und while. "
"identifiers":::"Ein Bezeichner ist der Name, der auf etwas im Code verweist (eine Variable, eine Methode, eine Klasse ...). Bei Bezeichnern in Java wird die Groß- und Kleinschreibung beachtet. Ein Bezeichner kann Folgendes enthalten: \ nJedes Unicode-Zeichen ist ein Buchstaben (einschließlich numerischer Buchstaben wie römische Ziffern) oder Ziffern. \ n- Das Währungszeichen (wie z. B. $). \ n- Der Unterstrich (wie z. B. _). \ nAber ein Bezeichner kann nicht: \ n1. Beginnen du mit einer Ziffer oder \ n2. Entspricht einem reservierten Schlüsselwort, null, wahr oder falsch. \ n3. Es dürfen nicht zwei identische Bezeichner für verschiedene Strukturen vorhanden sein. "
"types":::"Daten werden in verschiedenen Formen gespeichert, die als" types "bezeichnet werden. Die Daten, die einem bestimmten Typ entsprechen, können etwas in der Realität oder einer Idee darstellen. Beispielsweise können 3 Zeichenfolgen (Name, Nachname und Adresse) eine Identifikation für eine Person sein , oder 3 Ganzzahlen können eine Farbe im RGB-Format darstellen. Was ich beschrieben habe, sind benutzerdefinierte Typen. Es gibt jedoch auch eingebaute Typen (die als Bausteine ​​für benutzerdefinierte Typen verwendet werden können. Die eingebauten Typen werden als primitive Typen bezeichnet Es gibt Typen für Ganzzahlen (ganze Zahlen): char, int, long, short und byte, die sich im Bereich der darstellbaren Zahlen unterscheiden. ganze Zahlen: float und double. double können einen breiteren Bereich von Zahlen anzeigen. Der Typ char kann auch Zeichen darstellen und der Typ String stellen Zeichenfolgen dar. Der Typ boolean stellt die Werte true und false dar. \ n Hier sind die Bereiche für die verschiedenen Ganzzahlen Typen: \ n • Für Byte, von - 128 bis 127 \ n • Kurz, von -32768 bis 32767 \ n Für int, von -2147483648 bis 2147483647 \ n Lang, von -9223372036854775808 bis 9223372036854775807 \ n • Für char, von '\ u0000' bis '\ uffff' einschließlich, dh von 0 bis 65535. "
"variable_definition":::"Variablen können zum Speichern von Daten verwendet werden. Variablen haben einen Namen, einen Typ und einen Wert, der diesem Typ zugeordnet ist. Du wirst durch Schreiben des Variablentyps, des Variablennamens und eines Semikolons definiert. Beispiel: int var. "
"variable_definition_initialization":::"Eine Variable kann in derselben Anweisung definiert und initialidurt werden, indem ein Wert zugewiesen wird, der dem Typ entspricht (z. B .: int a = 9;)."
"variable_access":::"Auf eine zuvor definierte Variable kann mit deinem Bezeichner zugegriffen werden. Beispiel: Definition einer Variablen (int a;) und anschließender Zugriff (Ausdruck mit System.out.println ( );): System.out.println (a); "
"variable_reassignment":::"Eine Variable kann neu zugewiesen werden, indem ein passendes Literal, eine Variable, die Rückgabe einer Methode oder ein Array-Element desselben Typs zugewiesen wird."
lesson: arrays
"array_definition":::"Arrays enthalten eine Folge von Variablen desselben Typs. Zum Beispiel 3 ints. Du haben immer eine feste Größe. Arrays werden wie folgt definiert: type name []; oder this: type [] name ;. Es gibt absolut keinen Unterschied zwischen diesen beiden Varianten. Bevor du verwendet werden können, müssen du deklariert werden (die Anzahl der Elemente muss festgelegt werden). Ein Element eines Arrays kann wie eine "normale" Variable dieses Typs verwendet werden. "
"array_declaration":::"Eine Array-Deklaration beschreibt, wie viele Elemente ein Array enthält, und initialidurt du mit einem Standardwert (0 für Zahlen, der leere String für Strings, das leere Zeichen für Zeichen, true für Booleans oder null für andere Typen). Nach der Array-Deklaration kannst du das Array verwenden (Lesen und Schreiben). Du können zuerst ein Array definieren und es dann wie folgt deklarieren: Arraytyp Arrayname; Arrayname = neuer Typ [Elemente]; (z. B. int [] a; a = neu int [3];). Du können dies aber auch in einem Schritt tun: type [] name = new type [dimension] (zB int y [] = new int [2]; - ​​dies erzeugt das Array y mit 2 Elementen) Hinweis: Die Indizes beginnen bei 0. Das heißt, y hat zwei Elemente: y [0] und y [1]. "
"array_definition_initialization":::"Arrays können mit benutzerdefinierten Werten in einem Schritt wie folgt definiert, deklariert und initialidurt werden: type value [] = {value1, ..., valueN} (zB int a [] = {1,2, 3};). Diese Initialidurung kann nur einmal zusammen mit der Definition durchgeführt werden. "
"array_access":::"Auf Arrays wird folgendermaßen zugegriffen: name [index] (z. B. y [0])."
"array_reassignment":::"Ein einzelnes Element eines Arrays kann folgendermaßen neu zugewiesen werden: type [index] = value; (z. B. name [3] =" hans ";)."
"multidim_array_definition":::"Ein multidimensionales Array ist ein Array, das ein Array oder Arrays von Arrays oder Arrays von Arrays von Arrays enthält. Ein zweidimensionales Array besteht beispielsweise aus einem Array von Arrays. Das bedeutet, dass Elemente in der ersten Dimension ein eindimensionales Array haben In Java sind mehrdimensionale Arrays wie folgt definiert: Typname [] ... []; oder Typ [] ... [] Name; (zB int [] [ ] a; für ein zweidimensionales Array). Hier ein Beispiel: Ein Array mit der Größe 1920 * 1080 hat 1920 Elemente in der ersten Dimension. Jedes Element der ersten Dimension hat ein Array mit 1080 Elementen. Ein Array wie dieses könnte sein verwendet, um ein Full-HD-Bild zu beschreiben - jedes Element dieses Arrays würde ein Pixel darstellen. "
"multidim_array_declaration":::"Das multidimensionale Array kann folgendermaßen deklariert werden: type [] ... [] name = new type [dimension1] ... [dimensionN]; (zB int [] [] numbers = new int [ 3] [3]; - dies erzeugt das Array y mit 3 * 3 Elementen. "
"multidim_array_access":::"Auf multidimensionale Arrays wird folgendermaßen zugegriffen: name [index1] ... [indexN] (z. B. int a [] [] = {{1,2}, {3,4}; a [0] [1] ist 2.)
"multidim_array_reassignment":::"Syntax für die Neuzuweisung: Typ [Index1] ... [IndexN] = Wert; (z. B. ein [0] [0] = 1;)."
lesson: operators
"arithmetic_operators":::"Arithmetische Operatoren können int- und float-Literale verbinden, + können zusätzlich zur Verkettung von Strings verwendet werden. + ist Addition von Zahlen und Strings, - ist Subtraktion, * ist Multiplikation, / ist Division,% ist Modulo. Modulo ist der Rest aus einer ganzzahligen Division (zB 2% 4 ist 2, weil 2/4 0 ist, mit einem Rest von 2 (2 = 4 * 0 + 2). 5% 4 ist 1, weil 5/4 ist 1 Pause 1 (1 = 1 * 4 + 1). "
"operators_prefix":::"Inkrementieren bedeutet in Java, 1 zu addieren, um 1 von einer Ganzzahl zu subtrahieren. Um eine Variable von Ganzzahltypen (int, long, short, byte oder char) zu inkrementieren, den Inkrementierungsoperator ++ und um es zu dekrementieren, kann der Dekrementierungsoperator verwendet werden (zB ++ a ist gleich a + 1, --a ist gleich a-1) Wenn ein Inkrementierungs- oder Dekrementierungsoperator vor einer Variablen steht, wird der Wert inkrementiert / Zuerst dekrementiert und dann der Variablen zugewiesen (z. B. ++ a oder --a). Wenn ++ oder - vor eine Variable geschrieben werden, werden du Präfixoperatoren genannt. "
"operators_postfix":::"Der Inkrementierungs- oder Dekrementierungsoperator kann hinter eine Variable geschrieben werden (z. B. a ++). Wenn du nach einer Variablen geschrieben werden, wird die Variable zuerst zugewiesen und dann inkrementiert. Beispiel: Wenn die int-Variable a 3 ist , System.out.println (a ++); druckt 3 aus, weil a zugewiesen und dann inkrementiert wird. Das bedeutet, dass ein zusätzliches System.out.println (a); würde 4 ausgeben. Wenn ++ oder - nach einer Variablen geschrieben werden werden du als Postfix-Operatoren bezeichnet. "
"comparison_operators":::"Vergleichsoperatoren können zum Vergleichen von Zahlen verwendet werden. Kleiner als: <, größer als:>, kleiner als oder gleich: <=, größer als oder gleich:> =, ungleich:! = und gleich: == ganze Zahlen vergleichen und ein boolesches Literal zurückgeben. == und! = können auch jeden anderen Typ oder Null vergleichen, solange beide Operanden vom gleichen Typ sind. Es ist wichtig zu verstehen, dass in java = kein Vergleich ist , aber eine Zuweisung! == ist der gleiche Operator von Java. "
"logic_operators":::"Logikoperatoren können die booleschen Werte" true "oder" false "kombinieren. Als Operanden sind nicht nur die Literale" true "und" false "zulässig, sondern auch Variablen vom Typ" boolean "," boolean expressions ", Methoden, die" true "oder" false "zurückgeben oder daraus resultieren andere Vergleichsoperationen.! ist das logische NOT (zB! (3 <9) ergibt false), && ist das logische AND (zB (! true) && true ergibt false), || ist das logische OR (zB true |) | false wird zu true ausgewertet, true || true ist true) und ^ ist das logische XOR (true ^ false ist true). Die AND-Operation wird nur dann zu true ausgewertet, wenn BEIDE Operanden true sind (1 <3 && 3> 1 ist false). 1 <3 && true ist true). Die ODER-Operation wird als true ausgewertet, wenn MINDESTENS EIN Operand true ist (z. B. 1 <3 ^ 3> 1 ist true, 1> 3 ^ 3> 5 ist false. Die NICHT-Operation NEGATES a Boolescher Wert (! 1> 3 ist wahr,! true ist falsch.) Die XOR-Operation ist wahr, wenn genau einer der Operanden wahr ist (1 <3 || 3> 1 ist wahr, 1> 3 || 3> 5 ist wahr false) Die runden Klammern sind nicht erforderlich, werden jedoch für empfohlen Lesbarkeit. "
"bitwise_operators":::"Jeder Int-Typ wird durch eine Binärzahl (Nullen und Einsen) dargestellt (z. B. 4 wird durch 100 dargestellt). Bitweise Operatoren sind logische Funktionen auf Bitebene. Es gibt ~ für bitweises NICHT und & für bitweise AND, | für bitweises OR und ^ für bitweises XOR. Durch Interpretation einer 1 mit true und einer 0 mit false können diese Operationen auf int, short, long, char und byte angewendet werden. Beispiel: 3 | 2 ist 3, weil auf der Bitebene 0b11 | 0b01 ist 0b11. Außerdem gibt es die Operatoren <<, >> und >>>, die die Bits verschieben. a << n verschiebt die Binärdarstellung von a, n-mal nach links (0 wird links hinzugefügt). a >> n verschiebt sich ein Mal nach rechts und a >>> n verschiebt sich ein Mal nach rechts und behält das Vorzeichen von a bei. Wenn beispielsweise a 4 ist, dann ist a >> 1 2 (0b100 -> 0b10); a << 1 ist 8 (0b100 -> 0b1000). A und n können nur vom Typ int sein. "
"assignment_operators":::"= ist die einfache Zuweisung. Operatoren für komplexe Zuweisungen führen eine Operation aus und weisen dann den Wert dieser Operation in einem Schritt zu (z. B. entspricht a + = 3 a = a + 3). + =, - =, * =, / =,% = sind Zuordnungen nach Summe, Differenz, Produkt, Quotient, Rest. << =, >> =, >>> = sind Zuordnungen nach bitweiser Linksverschiebung, vorzeichenbehafteter Rechtsverschiebung und vorzeichenloser Rechtsverschiebung . & = ^ = | = sind Zuweisungen durch bitweises AND, XOR und OR. Jeder dieser Zuweisungsoperatoren führt zuerst die Operation aus und weist den neuen Wert zu. "
lesson: statements
"expressions":::"Ein Ausdruck ist ein Konstrukt aus Variablen, Operatoren und Methodenaufrufen. Ein Ausdruck kann immer ausgewertet werden. Beispiel 3 + A [0] wird zu 8 ausgewertet, wenn A [0] den Wert 5 hat . "
"statements":::"Anweisungen sind Ausführungseinheiten. Jede Anweisung muss mit einem Semikolon enden. Du können in drei Gruppen unterteilt werden: Ausdrucksanweisungen, Deklarationsanweisungen und Kontrollflussanweisungen (nächste Lektion). Ausdrucksanweisungen enthalten Zuweisungsausdrücke, ++ und - und Methodenaufruf (in zwei Lektionen). Deklarationsanweisungen enthalten eine beliebige Deklaration einer Variablen (oder eines Arrays). "
"code_blocks":::"Ein Block ist eine Folge von Anweisungen, die in {und} eingeschlossen sind. Ein Codeblock kann leer sein oder 1 oder mehrere Anweisungen enthalten. Ein Codeblock kann auch ... einen Codeblock / Codeblöcke enthalten Codeblöcke dienen zum Zusammenfassen von Anweisungen, die sich logisch auf eine Einheit beziehen, die später ausgeführt wird und verwendet werden kann (dh, Du wirst in Kontrollstrukturen, Methodendefinitionen, Klassen usw. verwendet). "
lesson: controll_structures
"boolean_expression":::"Ein boolescher Ausdruck ist ein Ausdruck, der mit wahr oder falsch bewertet werden kann (z. B .: 2 >> 1! = 7)."
"if":::"Die if-Anweisung führt eine Anweisung oder einen Codeblock aus, wenn ein boolescher Ausdruck wahr ist. \ nif (boolescher Ausdruck) {\ n // Codeblock \ n} \ nHier ist ein Beispiel: if (x < 0) {x * = - 1} (Nach diesem Ausdruck ist x immer positiv oder 0. Wenn x positiv oder 0 ist, wird die Anweisung nicht ausgeführt. Wenn x jedoch negativ ist (dh x <0 ist wahr) und Anweisung in geschweiften Klammern wird ausgeführt.). "
"switch":::"Eine switch-Anweisung ist eine Drop-Unterscheidung, dh eine Folge von if-Anweisungen. Die switch-Anweisung führt einen Codeblock aus, wenn eine Variable einen bestimmten Wert hat. Diese auf einem Wert badurende Reaktion wird als case bezeichnet. Die Syntax ist switch (Variable) {case value1: {/ * Anweisungen; * / break;}; ... default: / * Anweisungen; * / break;}. Der Standardfall wird ausgelöst, wenn kein anderer Fall vorliegt. Code für jeden case sollte mit dem break-Schlüsselwort enden, aber es ist möglich, es wegzulassen, wodurch die Ausführung zum nächsten Label weitergeht. switch-Anweisungen in Java können als Variablen byte, short, char und int verwenden. "
"while":::"Eine while-Schleife führt einen Codeblock aus, solange ein boolescher Ausdruck wahr ist. \ n Syntax: while (boolescher Ausdruck) {\ n // Codeblock \ n}. oder while (Ausdruck) // Anweisung. \ n Beispiel: int i = 0; while (i <10) {++ i; System.out.println (i);} Iteration i von 0 bis 10. "
"do_while":::"In der do-while-Schleife wird der Test nach jeder Iteration durchgeführt. Folglich wird der Code immer mindestens einmal ausgeführt. Die Syntax lautet: do {/ * Codeblock * /} while (Boolescher Ausdruck ); \ n int i = 0; mache {++ i; System.out.println (i);} while (i <10); werde i von 0 bis 10 durchlaufen. "
"for":::"Eine for-Schleife iteriert eine Variable und führt einen Codeblock aus, solange eine Bedingung erfüllt ist. for-Schleifen in Java enthalten einen Initialidurer (z. B. int a = 0;), einen booleschen Ausdruck (z. B. false oder a <10) und ein Zählerausdruck (zB ein ++), aber der Initialidurer und der Zählerausdruck können beliebige Anweisungen sein. Die Syntax lautet: for (Anweisung; boolescher_Ausdruck; Anweisung) {/ * Codeblock * /} \ n Hier ein Beispiel: für (int i = 0; i <10; i ++) {System.out.println (i);}. \ nDie beiden Anweisungen und der boolesche Ausdruck können leer sein: for (;;); ist eine gültige, unendliche for-Schleife . "
"extended_for":::"Die erweiterte for-Schleife durchläuft alle Elemente eines Arrays. Die Syntax lautet: for (variable_definition: array_name) {/ * codeblock * /} \ nZum Beispiel: String [] names = {" anna ", "john", "mary", "bob"}; für (String name: names) System.out.println (name); Ausgabe: "anna", "john", "mary", "bob". "
"break":::"Die Anweisung break; kann verwendet werden, um eine Schleife vorzeitig zu verlassen. Beispiel: for (int i = 0; i <9; i ++) {if (i * i> = 9) break;} will Brechen du die Schleife bei i = 3. "
"continue":::"continue; kann verwendet werden, um zum Anfang der Schleife zu springen und so eine Iteration zu überspringen. Beispiel: for (int i = 0; i <9; i ++) {if (i% 2 == 0) Fortsetzen; überspringt alle Iterationen, bei denen ich gerade bin. ”
lesson: methods
"method_definition":::"Mit einer Methode kannst du einen Codeblock badurend auf Parametern ausführen und eine Variable / ein Array zurückgeben. Die Parameter sollten bestimmen, was im Codeblock pasdurt und was das Ergebnis der Methode ist. Methoden werden in a definiert . Klasse die Syntax für eine gültige Methode Definition lautet: \ n access_modifier Modifikator Rückgabetyp Name (Parameterliste) {/ * functionbody mit return-Anweisung * /} \ n die Parameterliste ist eine Liste der variablesdefinitions (ohne;), die durch getrennt ist. ",". Diese einfache Methode kann zum Beispiel die Summe zweier int-Variablen zurückgeben: public static int square (int a) {return a * a;}. Square hat die Modifikatoren public und static, die bestimmen, wie auf die Methode zugegriffen wird. square ist der Name der Methode, int ist der Typ, der zurückgegeben wird - der Typ des Ergebnisses. Der Parameter int a bestimmt, mit welchen Arten von Argumenten auf diese Methode zugegriffen werden kann (aufgerufen). (Alles, was zu einem int ausgewertet werden kann (int literal, in) \ n Es muss keinen Parameter geben oder einen Rückgabewert. (Du würdest dann nur als Rückgabe stornieren). Die kürzeste Methodendefinition lautet also: void a () {}. Diese Methode wird eigentlich nichts tun. \ n void a (int a, String b) {} macht dasselbe, muss aber mit einem int und einem String aufgerufen werden. "
"method_modifiers"::: "Methoden können verschiedene Modifikatoren in ihrer Definition haben, die sich ändern, wie auf du zugegriffen wird abstrakt -.. Abstrakte Methoden in abstrakten Klassen nur vorhanden sein können Solche Verfahren haben keinen Körper und muss in einer Unterklasse überschrieben werden, wenn es abstrakt ist . selbst statisch - macht die Methode statisch und damit zugänglich mit der Klasse, ohne Schaffung einer Klasseninstanz jedoch statische Methoden nicht nicht-statische Member in der gleichen Klasse zugreifen eine statische Methode würde wie folgt aufgerufen werden: classname.methodname (parameter~~POS=TRUNC.. ) ;. final erklärt, dass das Verfahren nicht in einer Unterklasse überschrieben wird Zugriffsmodifikatoren die mit Klassen identisch sind:.. öffentlich, geschützt, privat keine Sorge, ich Ihnen erklären, welche Klassen in der nächsten Lektion sind und was Diese Zugriffsmodifikatoren bedeuten. "
"method_access":::"Auf Methoden kann auf verschiedene Arten zugegriffen werden. Auf statische Methoden wird über den Klassennamen zugegriffen: classname.method (parameter) (zB Math.min (2,3);). Eine statische Methode, die in a definiert wurde Auf die Klasse kann ohne Klassennamen zugegriffen werden (zB min (3,4);). Auf Member-Methoden (nicht statisch) wird über ein Objekt dieser Klasse zugegriffen (egxequals (y);). Methoden können andere Methoden als Argumente verwenden (if der Parameter und der Argumenttyp stimmen überein) (zB System.out.println (Math.min (2,3));). "
lesson: classes
"class_definition":::"Klassen bieten wie Methoden eine Möglichkeit, Code kompakter zu schreiben und Code wiederzuverwenden. Klassen können wie folgt definiert werden: Klassenname {// Klassenfelder und Klassenmethoden}. Klassenkonstruktoren können wie folgt definiert werden: public name (parameter) {// Konstruktor}. Eine Klassendefinition kann Variablendefinitionen und Methodendefinitionen enthalten (die als ihre Mitglieder bezeichnet werden). "
"class_modifiers":::"Wie bei Methoden gibt es einige Modifikatoren zum Ändern der Barrierefreiheit. abstract - Gibt an, dass eine Klasse nur als Basisklasse dient und nicht instanziiert werden kann. static - Wird nur für Elementklassen verwendet. Gibt an, dass die Elementklasse verwendet wird gehört nicht zu einer bestimmten Instanz der enthaltenden Klasse. final - Klassen, die als final markiert sind, können nicht erweitert werden und dürfen keine Unterklassen haben. "
"inheritance":::"Eine Klasse kann Methoden und Variablen an untergeordnete Klassen erben. Die Syntax hierfür duht folgendermaßen aus: class child_class extended parent_class {...}. \ n Beispiel: \ n class Person {String name;} \ n Klassenlehrer erweitert Person {void change_name (String newname) {this.name = newname;}}. Der Klassenlehrer erbt den Variablennamen von Person und kann ihn in change_name verwenden. Kinder können von Kindern erben und so weiter kann eine Vererbungshierarchie aufbauen. "
"access_modifiers":::"Zugriffsmodifikatoren geben an, wo du eine Klassendefinition sehen und daher instanziieren (ein Objekt erstellen). public: von überall; protected: von einer erweiterten Klasse in einem anderen Paket; package (Standard): andere Klassen innerhalb desselben Pakets (dieser Modifikator kann nicht als Schlüsselwort verwendet werden); privat: gleiche Klasse oder verschachtelte Klasse. Wenn beispielsweise eine Klasse A eine private Klasse B enthält, kann nur A B verwenden. "
"object_declaration":::"Wenn eine Klasse definiert wurde, kannst du ein Objekt dieser Klasse deklarieren. Dieses Objekt enthält alle Variablen, die du für die Klasse definiert haben, und kann alle in der Klassendefinition definierten nicht statischen Methoden verwenden. Die Syntax lautet: classname objectname = new classname () ;. "
"class_fields":::"Felder oder Klassenvariablen können innerhalb des Klassenkörpers deklariert werden, um einen Zustand (Variablen) zu beschreiben oder das Verhalten von Objekten (Methoden) zu ändern. Zum Beispiel: class number {int value = 0; \ n Auf du kann folgendermaßen zugegriffen werden: objectname.member ;. Wenn das Feld statisch ist, kann über classname: classname.member ;. auf Felder zugegriffen werden von der Klasse, kein Objekt) .finale - Ermöglicht die einmalige Initialidurung des Feldes in einem Konstruktor oder innerhalb des Initialidurungsblocks oder während seiner Deklaration, je nachdem, welcher Zeitpunkt früher liegt. Felder können mit Zugriffsmodifikatoren geändert werden. Ein Objekt kann sein Mitglied erreichen mit dem Schlüsselwort this. Beispiel: this.a ;. "
"member_access_variables":::"Der Operator . ermöglicht den Zugriff auf eine Variable einer Klasse (z. B. player_one.name).
"member_access_methods":::"Der Operator . ermöglicht auch den Zugriff auf eine Member-Methode einer Klasse (z. B. player_one.getName()).